(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{223:function(n,t,e){"use strict";e.r(t);var o=e(0),r=Object(o.a)({},(function(){var n=this.$createElement,t=this._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[t("blockquote",[t("p",[this._v("假设浏览器窗口滚动条滚动时会调用一个方法fn,下面一步步实现一个节流函数.")])]),this._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[this._v("* 第一个版本\n     * 缺点:产生了全局变量\n<script>\n    var timer;\n    window.onscroll = function () {\n        clearTimeout(timer);\n        timer = setTimeout(function () {\n            console.log('window scroll...');\n        }, 200);\n    }\n<\/script>\n\n\n     * 第二个版本,使用闭包来封装全局变量\n     * 缺点:如果用户不停的滚动滚动条,那么延时函数一次都不会触发\n<script>\n    var throttle = function (fn, delay) {\n        var timer = null;\n        return function () {\n            clearTimeout(timer);\n            timer = setTimeout(function () {\n                fn();\n            }, delay);\n        }\n    }\n    var f = throttle(testFn, 200);\n    window.onscroll = function () {\n        f();\n    };\n<\/script>\n\n      * 于是我们又要添加一个功能：当用户触发 scroll 的时候应该 在某段时间 内至少触发一次，既然是在某段时间内，\n      * 那么这个判断条件就可以取当前的时间毫秒数，每次函数调用把当前的时间和上一次调用时间相减，然后判断差值如果大于 某段时间 就直接触发，\n      * 否则还是走 timeout 的延迟逻辑。\n      下面的代码里面需要指出的是：\n      1. previous 变量的作用和 timer 类似，都是记录上一次的标识，必须是相对的全局变量\n      2. 如果逻辑流程走的是“至少触发一次”的逻辑，那么函数调用完成需要把 previous 重置成当前时间，简单来说就是：相对于下一次的上一次其实就是当前\n     \n<script>\n\n   var COUNT = 0, demo = document.getElementById('demo');\n    function testFn() {\n        demo.innerHTML += 'testFN 被调用了 ' + ++COUNT + '次<br>';\n    }\n    var throttle = function (fn, delay, atleast) {\n        var timer = null;\n        var previous = null;\n        return function () {\n            var now = +new Date();\n            if (!previous) previous = now;\n            if (atleast && now - previous > atleast) {\n                fn();\n                // 重置上一次开始时间为本次结束时间\n                previous = now;\n                clearTimeout(timer);\n            } else {\n                clearTimeout(timer);\n                timer = setTimeout(function () {\n                    fn();\n                    previous = null;\n                }, delay);\n            }\n        }\n    };\n    window.onscroll = throttle(testFn, 200);\n    // window.onscroll = throttle(testFn, 500, 1000);\n<\/script>\n\n<script>\n    document.getElementById(\"btn\").onclick = throttle(function () {\n        console.log(\"button click...\");\n    }, 2000);\n\n    //debounce用于将相同的操作积累到一起再触发，节省性能\n    function debounce(fn, delay) {\n        var timer = null;\n        return function () {\n            clearTimeout(timer);\n            timer = setTimeout(function () {\n                return fn.apply(this, arguments);\n            }, delay);\n        }\n    }\n<\/script>\n")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);