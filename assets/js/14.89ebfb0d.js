(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{215:function(t,a,s){"use strict";s.r(a);var v=s(0),d=Object(v.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"什么是虚拟dom？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是虚拟dom？"}},[t._v("#")]),t._v(" 什么是虚拟dom？")]),t._v(" "),s("p",[t._v("这就要从react如何渲染出页面开始\n通常情况下的步骤是这样")]),t._v(" "),s("ol",[s("li",[t._v("获取state数据")]),t._v(" "),s("li",[t._v("JSX模板")]),t._v(" "),s("li",[t._v("state+JSX模板结合，生成真实dom并显示")])]),t._v(" "),s("p",[t._v("这个是在state不发生变化的情况下，（state或者prop发生变化都会调用render函数，重新渲染页面）")]),t._v(" "),s("p",[t._v("state数据变化时，通常理解下应该是下面的步骤")]),t._v(" "),s("ol",[s("li",[t._v("获取state数据")]),t._v(" "),s("li",[t._v("JSX模板")]),t._v(" "),s("li",[t._v("state数据+JSX模板结合，生成真实dom并显示")]),t._v(" "),s("li",[t._v("state数据发生变化")]),t._v(" "),s("li",[t._v("新的state数据+JSX模板结合，生成真实dom并显示")])]),t._v(" "),s("p",[t._v("这样可以实现，但是非常消耗性能，因为会渲染两次dom树，所以react就采用一种虚拟dom的方法来进行dom更新。")]),t._v(" "),s("p",[t._v("JSX转成dom流程")]),t._v(" "),s("blockquote",[s("p",[t._v("用JSX语法时，渲染dom的流程：JSX——JS dom描述对象——真实dom")])]),t._v(" "),s("p",[t._v("具体步骤：")]),t._v(" "),s("ol",[s("li",[t._v("获取state数据")]),t._v(" "),s("li",[t._v("JSX模板")]),t._v(" "),s("li",[t._v("生成虚拟dom（虚拟dom就是一个JS对象，里面包含了对真实dom的描述")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("['div',{id:'a'},['span',{},'hello']]\n")])])]),s("ol",{attrs:{start:"4"}},[s("li",[t._v("用虚拟dom解构，生成真实dom并显示")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("<div id='a'><span>hello</span></div>\n")])])]),s("ol",{attrs:{start:"5"}},[s("li",[t._v("state数据发生变化（比如hello变成了hi）")]),t._v(" "),s("li",[t._v("生成新的虚拟dom")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("['div',{id:'a'},['span',{},'hi']]\n")])])]),s("ol",{attrs:{start:"7"}},[s("li",[t._v("比较原始虚拟dom和新的虚拟dom的区别，找出区别是span里的内容")]),t._v(" "),s("li",[t._v("直接操作dom，只改变span里的内容")])]),t._v(" "),s("h4",{attrs:{id:"虚拟dom的好处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom的好处"}},[t._v("#")]),t._v(" 虚拟dom的好处")]),t._v(" "),s("ol",[s("li",[t._v("性能提升，dom比对变成js对象比对")]),t._v(" "),s("li",[t._v("使得跨端应用得以实现（react native）")])]),t._v(" "),s("blockquote",[s("p",[t._v("在浏览器中可以用虚拟dom生成真实dom显示，在原生应用中也可以用虚拟dom生成对应的方式来显示页面")])]),t._v(" "),s("h2",{attrs:{id:"虚拟dom中的diff算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom中的diff算法"}},[t._v("#")]),t._v(" 虚拟dom中的diff算法")]),t._v(" "),s("p",[t._v("在上面我们介绍了react中state变化时，dom是如何发生变化的，在第七步中比较原始虚拟dom和新的虚拟dom的区别采用的方法，就是diff算法（diffrence）")]),t._v(" "),s("p",[t._v("虚拟dom在什么时候会发生比对？没错，数据发生变化时，也就是调用setState时")]),t._v(" "),s("p",[t._v("react的虚拟dom其实是同级比较的")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/30/1689dac3232d3b6d?w=582&h=300&f=png&s=69471",alt:""}}),t._v("\n如上图\n他的对比步骤如下")]),t._v(" "),s("ol",[s("li",[t._v("红色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对")]),t._v(" "),s("li",[t._v("蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对")]),t._v(" "),s("li",[t._v("绿色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对，浅蓝色原始虚拟dom和新的虚拟dom，没有变化，保持不变，往下继续比对")])]),t._v(" "),s("blockquote",[s("p",[t._v("但凡在上面哪一步骤出现不同，就不再继续比对，而是删除下面的全部节点，采用新的虚拟dom(例如：如果红色框的原始虚拟dom和新的虚拟dom不一致，那么就不在进行比对，采用新的虚拟dom来生成dom)")])]),t._v(" "),s("h4",{attrs:{id:"key的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#key的作用"}},[t._v("#")]),t._v(" key的作用")]),t._v(" "),s("p",[t._v("react利用key来识别组件，它是一种身份标识标识，来提高虚拟dom的比对速度看下面")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/30/1689dbb06ec80cda?w=477&h=191&f=png&s=7412",alt:""}}),t._v("\n比如我要在abcde中添加一个f")]),t._v(" "),s("p",[t._v("如果我们没有key值，那我们就需要A比对一遍，B对比一遍，以此类推很好性能，而有了key，就像下面的图一样，我们很快就知道只有f与之前不同，提高了列表渲染的性能\n"),s("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/1/30/1689dbbc688199b4?w=565&h=201&f=png&s=11659",alt:""}})])])}),[],!1,null,null,null);a.default=d.exports}}]);