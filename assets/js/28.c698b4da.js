(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{229:function(t,e,n){"use strict";n.r(e);var s=n(0),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("ajax其实是实现异步刷新，他的用处是在不重新载入页面的情况下，与与服务器交换数据并更新网页。\n看下面的例子,不着急看懂，后面我会详细解释")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('<span>输入账号</span>\n<input id="name" name="name" onkeyup="check()" type="text">  \n<span id="checkResult"></span>\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<script>\nvar xmlhttp;\nfunction check(){\nvar name =document.getElementById('name').value;\nvar url=\"/study/checkName.jsp?name=\"+name;\n\nxmlhttp =new XMLHttpRequest(); \n  xmlhttp.onreadystatechange=checkResult; //响应函数\n  xmlhttp.open(\"GET\",url,true);   //设置访问的页面\n  xmlhttp.send(null);  //执行访问\n\nfunction checkResult(){\n  if (xmlhttp.readyState==4 && xmlhttp.status==200)\n    document.getElementById('checkResult').innerHTML=xmlhttp.responseText;\n  \n}\n<\/script>\n")])])]),n("p",[t._v("第一步：ajax请求的示意图如下，大概了解是怎么走的：\n"),n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/21/167cf29b4557b6c0?w=495&h=345&f=png&s=23735",alt:""}})]),t._v(" "),n("p",[t._v("第二步：创建XMLHttpRequest（XHR）\nXHR是一个javascript对象，他是在幕后通过一个小线程与服务器进行数据交互的，从而实现无刷新效果。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("<script>\nvar xmlhttp = new XMLHttpRequest();\ndocumen.write(xmlhttp);\n<\/script>\n")])])]),n("p",[t._v("结果：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("[object XMLHttpRequest]\n")])])]),n("p",[t._v("第三步：设置响应函数\nXHR对象的作用是和服务器进行交互，所以不仅发送消息给服务器，也接受服务器返回的响应。当从服务器返回响应时我们想做点什么该怎么办？\n通过xmlhttp.onreadystatechange=checkResult 就可以指定用checkResult 函数进行处理。")]),t._v(" "),n("p",[t._v("第四步：设置并发出请求\n通过open函数设置幕后的小线程，将要访问的url。在本例中就是 /study/checkName.jsp")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("xmlhttp.open('GET',url,true);//规定请求的类型、URL 以及是否异步处理请求。method：请求的类型；GET 或 POST url：文件在服务器上的位置 async：true（异步）或 false（同步）\n")])])]),n("p",[t._v("通过send函数进行实际的访问")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("xmlhttp.send(null);//send(string),将请求发送到服务器。\n")])])]),n("p",[t._v("第五步：处理响应信息\n在checkResult 函数中处理响应")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function checkResult(){\n  if(xmlhttp.readyStats==4 && xmlhttp.status ==200)\n   document.getElementById('checkResult').innerHTML=xmlhttp.responseText;\n}\n")])])]),n("p",[t._v("xmlhttp.readyState 4 表示请求已完成\nxmlhttp.status 200 表示响应成功\nxmlhttp.responseText; 用于获取服务端传回来的文本\ndocument.getElementById('checkResult').innerHTML 设置span的内容为服务端传递回来的文本")]),t._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/21/167cf29b456d09ab?w=605&h=268&f=jpeg&s=21414",alt:""}})]),t._v(" "),n("p",[t._v("再返回来看第一段代码，是不是就理解了呢")])])}),[],!1,null,null,null);e.default=a.exports}}]);