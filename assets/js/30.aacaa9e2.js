(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{231:function(t,s,n){"use strict";n.r(s);var a=n(0),e=Object(a.a)({},(function(){var t=this,s=t.$createElement,n=t._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("首先，“语法糖”的意思是现有技术本可以实现，但是采用某种写法会更加简洁优雅。最常见的就是声明对象采用的就是语法糖 var a={b:111}。\nES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.toString = function () {\n  return '(' + this.x + ', ' + this.y + ')';\n};\n")])])]),n("p",[t._v("等同于")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("class Point {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n}\n")])])]),n("p",[t._v("在constructor中必须调用 super方法，子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。super代表了父类构造函数。对于你的实例相当于执行Component(props)。但是注意，此处this指向 子类。更严谨的是相当于")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Component.prototype.constructor.call(this,props)。\n")])])])])}),[],!1,null,null,null);s.default=e.exports}}]);