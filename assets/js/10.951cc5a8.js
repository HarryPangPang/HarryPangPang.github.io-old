(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{210:function(n,a,t){"use strict";t.r(a);var e=t(0),s=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("blockquote",[t("p",[n._v("什么是内存泄露？\n程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。\n对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。\n白话解释就是你写的代码里有些东西不用了，就别在保存再内存中了，不然好比你开了100个迅雷CPU卡不卡？卡，但你其实真正用到的只是其中一个迅雷。这就是内存泄漏")])]),n._v(" "),t("p",[n._v("想要理解JavaScript的内存泄漏，就要先了解一下js的自动垃圾收集机制")]),n._v(" "),t("h4",{attrs:{id:"js的自动垃圾收集机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js的自动垃圾收集机制"}},[n._v("#")]),n._v(" js的自动垃圾收集机制")]),n._v(" "),t("p",[n._v("在编写JS时，我们不用像C++一样要手工跟踪内存的使用情况，JS的内存分配和无用内存的回收完全实现了自动化。")]),n._v(" "),t("p",[n._v("JS常用的垃圾收集机制有两种：1. 标记清除 2. 引用计数")]),n._v(" "),t("ol",[t("li",[n._v("标记清除\n在函数声明一个变量的时候，就将这个变量标记为“进入环境”。从逻辑上讲，永远都不能释放进入环境的变量作占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。垃圾回收器在运行时候会给存储在内存中中的所有变量都加上标记。然后它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。在此之后再被标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清楚工作，销毁那些带标记的值并回收他们所占用的内存空间")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v(" \nfunction test(){ \n var a = 10 ; //被标记 ，进入环境 \n var b = 20 ; //被标记 ，进入环境 \n} \ntest(); //执行完毕 之后 a、b又被标离开环境，被回收。\n\n\n \n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[n._v("引用计数（现代浏览器不再使用）\n  引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。")])]),n._v(" "),t("p",[n._v("但是很重要的一点是当遇到循环引用的时候，函数的引用次数就不会为0，所以不会被垃圾回收器回收内存，会造成内存泄露。在IE中涉及DOM对象，就会存在循环引用的问题。")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('\n \nfunction test(){ \n var a = {} ; //a的引用次数为0 \n \n var b = a ; //a的引用次数加1，为1 \n \n var c =a; //a的引用次数再加1，为2 \n \n var b ={}; //b解除对a的引用，a的引用次数减1，为1 \n}\n\n// 循环引用\nfunction cycle() {\n    var o1 = {};\n    var o2 = {};\n    o1.a = o2;\n    o2.a = o1; \n\n    return "cycle reference!"\n}\ncycle();\n\n//数组\nlet arr = [1,2,3]\n\n虽然这里没有引用arr，arr对他的值发生了引用，所以会一直存在内存中，可以采用 arr=null来解除引用\n')])])]),t("p",[n._v("虽然有了自动垃圾收集机制，我们可以不必太过关注一些内存泄漏的问题，但有些情况下还是会发生这种问题")]),n._v(" "),t("h4",{attrs:{id:"js的常见内存泄漏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js的常见内存泄漏"}},[n._v("#")]),n._v(" js的常见内存泄漏")]),n._v(" "),t("ol",[t("li",[n._v("全局变量引起的内存泄漏")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function leaks(){  \n    leak = 'xxxxxx';//leak 成为一个全局变量，不会被回收\n}\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[n._v("闭包引起的内存泄漏")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var leaks = (function(){  \n    var leak = 'xxxxxx';// 被闭包所引用，不会被回收\n    return function(){\n        console.log(leak);\n    }\n})()\n")])])]),t("ol",{attrs:{start:"3"}},[t("li",[n._v("dom清空或删除时，事件未清除导致的内存泄漏")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("<div id=\"container\">  \n</div>\n\n$('#container').bind('click', function(){\n    console.log('click');\n}).remove();\n\n// zepto 和原生 js下，#container dom 元素，还在内存里jquery 的 empty和 remove会帮助开发者避免这个问题\n\n<div id=\"container\">  \n</div>\n\n$('#container').bind('click', function(){\n    console.log('click');\n}).off('click').remove();\n//把事件清除了，即可从内存中移除\n")])])]),t("ol",{attrs:{start:"4"}},[t("li",[n._v("计时器或回调函数\n定时器setInterval")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var a = fun();\nsetInterval(function(){\n  var node = document.getElementById('node');\n  if(node){\n     node.innerHTML = 'test';\n  }\n}，1000);\n")])])]),t("p",[n._v("节点node或数据不需要时，定时器setInterval依然指向这些数据，所以即使node节点被溢出，interval仍旧存活并且垃圾回收期没法回收。")]),n._v(" "),t("p",[n._v("解决是终止定时器。")]),n._v(" "),t("p",[n._v("这种循环定时器，是一定要设置关闭条件，然后将其clear并且将timer指向null]")]),n._v(" "),t("h4",{attrs:{id:"解决方法及性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解决方法及性能优化"}},[n._v("#")]),n._v(" 解决方法及性能优化")]),n._v(" "),t("p",[n._v("发生内存泄漏肯定是不愿看到的，我们可以采取：\n一旦确定数据不再使用，可以手动将其值设置为null来释放其引用。 —— 解除引用。")])])}),[],!1,null,null,null);a.default=s.exports}}]);