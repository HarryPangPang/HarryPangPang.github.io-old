(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{212:function(t,n,e){"use strict";e.r(n);var o=e(0),l=Object(o.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("#####1.1执行环境\n执行环境可以简称为环境，可以理解为JS被解析和执行所在的外部环境。\n#####1.1.1全局执行环境\n全局执行环境是最外层的一个环境，根据宿主环境的不同，全局对象也会有所区别，比如在浏览器中全局环境是window，在node中全局环境就是这个文件的module对象。\n#####1.1.2函数执行环境\n每次调用一个函数时，都会创建一个新的执行环境，在这个函数内的任何声明都无法在该函数之外的地方访问\n#####1.1.3Eval函数执行环境\n在eval()函数中的代码，不建议使用")]),t._v(" "),e("p",[t._v("#####1.1.4 执行栈\n我们先了解一下执行栈内的执行顺序：后进先出，意思就是最早来的最晚走，最后来的最先走（参考下图理解）\n"),e("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/12/21/167cf228b8c8df0f?w=555&h=288&f=png&s=52150",alt:"image.png"}})]),t._v(" "),e("blockquote",[e("p",[t._v("因为JavaScript在浏览器环境中的执行是单线程（就是一次只能做一件事，不能边吃饭边看电视，只能先吃饭再看电视），对于多个任务，只能采用任务队列的方式（就是先吃饭，一定要等吃完饭才能看电视）。")])]),t._v(" "),e("p",[t._v("举一个例子（暂时不用去看current execution context这一层，其实就是Execution Context N+1），")]),t._v(" "),e("ol",[e("li",[t._v("调用 一个函数f1，执行流先进入全局环境\n（Global Execution Context这一层）")]),t._v(" "),e("li",[t._v("f1的环境被推入环境栈中\n（Execution Context N+1这一层按照绿色箭头进入）")]),t._v(" "),e("li",[t._v("这时候函数f1又调用了函数f2，f2的环境被推入环境栈中\n（Execution Context N+2这一层按照绿色箭头进入）")]),t._v(" "),e("li",[t._v("f2执行完之后就立马离开执行栈\nExecution Context N+2这一层按照红箭头离开")]),t._v(" "),e("li",[t._v("f1执行完之后在f2离开环境栈后再离开环境栈\nExecution Context N+1这一层按照红箭头离开")]),t._v(" "),e("li",[t._v("全局环境不会消失，除非关闭浏览器或者关闭网页所以Global Execution Context这一层不会消失")])]),t._v(" "),e("blockquote",[e("p",[t._v("看到这里，我们就能理解另外一个概念：执行环境的两个阶段\n######1. 创建阶段")]),t._v(" "),e("ul",[e("li",[t._v("当函数被调用，但是为执行内部代码之前:")]),t._v(" "),e("li",[t._v("创建一个作用域链")]),t._v(" "),e("li",[t._v("创建变量，函数和参数。")]),t._v(" "),e("li",[t._v("确定this的值。\n######2, 执行阶段")]),t._v(" "),e("li",[t._v("赋值，引用函数，解释/执行代码。")])])])])}),[],!1,null,null,null);n.default=l.exports}}]);