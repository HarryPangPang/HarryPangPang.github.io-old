(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{232:function(n,e,a){"use strict";a.r(e);var t=a(0),s=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("p",[n._v("我们日常中经常使用各种cli来加速我们的工作，你们也一定和我一样想知道这些cli内部都干了什么？接下来我们就以实现一个koa-generator来打开脚手架工具的大门，来跟着我一步一步做吧：")]),n._v(" "),a("p",[a("code",[n._v("为了加快我们的学习进度，更快的理解cli，我们这里会省略一些内容，旨在帮助大家更快建立基本的概念和入门方法")])]),n._v(" "),a("h3",{attrs:{id:"需求分析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#需求分析"}},[n._v("#")]),n._v(" 需求分析")]),n._v(" "),a("p",[n._v("首先我们先对我们要实现的工具做一个简单的需求分析：")]),n._v(" "),a("ol",[a("li",[n._v("自动化生成koa初始项目结构")]),n._v(" "),a("li",[n._v("可以自定义一些内容")]),n._v(" "),a("li",[n._v("发布")])]),n._v(" "),a("p",[n._v("是不是很简单？没错，真的很简单！")]),n._v(" "),a("h3",{attrs:{id:"逐步实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#逐步实现"}},[n._v("#")]),n._v(" 逐步实现")]),n._v(" "),a("h4",{attrs:{id:"_1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1"}},[n._v("#")]),n._v(" 1")]),n._v(" "),a("p",[n._v("想要自动化生成koa初始项目结构的前提，就是要知道我们构建出来的结构是什么样的：")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/9/16a9b4ab026e0644?w=299&h=371&f=png&s=17255",alt:""}})]),n._v(" "),a("p",[n._v("上图就是我们想要生成的项目结构")]),n._v(" "),a("p",[n._v("明确了我们的目的接下来就开始着手吧！")]),n._v(" "),a("h4",{attrs:{id:"_2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2"}},[n._v("#")]),n._v(" 2")]),n._v(" "),a("h4",{attrs:{id:"_2-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1"}},[n._v("#")]),n._v(" 2.1")]),n._v(" "),a("p",[n._v("创建文件夹")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("mkdir koa-simple-generator\n")])])]),a("h4",{attrs:{id:"_2-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2"}},[n._v("#")]),n._v(" 2.2")]),n._v(" "),a("p",[n._v("进入项目目录")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("cd koa-simple-generator\n")])])]),a("h4",{attrs:{id:"_2-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3"}},[n._v("#")]),n._v(" 2.3")]),n._v(" "),a("p",[n._v("初始化npm（等不及实践就一路enter，后面也可以再做修改）")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("npm init\n")])])]),a("h4",{attrs:{id:"_2-4"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-4"}},[n._v("#")]),n._v(" 2.4")]),n._v(" "),a("p",[n._v("打开我们的package.json，如下")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/9/16a9b511c3717d41?w=498&h=235&f=png&s=14605",alt:""}})]),n._v(" "),a("p",[n._v("将下面的代码复制到package.json里")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('{\n  "name": "koa-simple-generator",\n  "version": "1.0.0",\n  "description": "",\n  "scripts": {\n    "test": "echo \\"Error: no test specified\\" && exit 1"\n  },\n  "author": "",\n  "license": "ISC",\n\n\n  "main": "bin/wowKoa",\n  "bin": {\n    "koa2": "./bin/wowKoa"\n  },\n  "dependencies": {\n    "commander": "2.7.1",\n    "mkdirp": "0.5.1",\n    "sorted-object": "1.0.0"\n  },\n  "devDependencies": {\n    "mocha": "2.2.5",\n    "rimraf": "~2.2.8",\n    "supertest": "1.0.1"\n  },\n  "engines": {\n    "node": ">= 7.0"\n  }\n}\n')])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('1. dependencies和devDependencies简单来说就是应用的依赖包，devDependencies只会在开发环境安装\n\n2. 这句话的意思是我们的这个工具需要node7.0及以上的版本才能支持\n"engines": {\n    "node": ">= 7.0"\n  }\n\n重点是这两句\n"main": "bin/wowKoa",\n  "bin": {\n    "wowKoa": "./bin/wowKoa"\n  },\n  意思是默认执行的是bin目录下的wowKoa，\n  执行wowKoa的命令，执行的也是bin目录下的wowKoa，\n  \n')])])]),a("p",[n._v("####2.5\n接下来安装我们的依赖吧")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("npm i\n")])])]),a("h4",{attrs:{id:"_2-6"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-6"}},[n._v("#")]),n._v(" 2.6")]),n._v(" "),a("p",[n._v("安装完，我们新建一个目录template")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("mkdir template\n")])])]),a("p",[n._v("然后我们可以把我们想要生成的目录结构拷贝进去，这里我就只是把koa2的目录拷贝进去，现在我们的目录长这样：")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/9/16a9b5f29ca24773?w=256&h=240&f=png&s=10184",alt:""}})]),n._v(" "),a("h4",{attrs:{id:"_2-7"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-7"}},[n._v("#")]),n._v(" 2.7")]),n._v(" "),a("p",[n._v("新建bin目录，在bin下新建文件wowKoa")]),n._v(" "),a("p",[a("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2019/5/9/16a9b632f0c8d54e?w=314&h=166&f=png&s=7354",alt:""}})]),n._v(" "),a("h4",{attrs:{id:"_2-8"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-8"}},[n._v("#")]),n._v(" 2.8")]),n._v(" "),a("p",[n._v("接下来就是关键了，我们的所有工作都是在bin下的wowKoa文件里完成的\n直接复制粘贴下面的，然后进入项目目录运行"),a("code",[n._v("node bin/wowKoa")]),n._v("就能看到结果了")]),n._v(" "),a("p",[a("em",[n._v("代码我已经大部分都注释啦")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("#!/usr/bin/env node\n // 告诉Unix和Linux系统这个文件中的代码用node可执行程序去运行\nvar program = require('commander');\nvar mkdirp = require('mkdirp');\nvar os = require('os');\nvar fs = require('fs');\nvar fsm = require('fs-extra')\nvar path = require('path');\nvar readline = require('readline');\nvar pkg = require('../package.json');\n\n// 退出node进程\nvar _exit = process.exit;\n// s.EOL属性是一个常量，返回当前操作系统的换行符（Windows系统是\\r\\n，其他系统是\\n）\nvar eol = os.EOL;\n\n\n\nvar version = pkg.version;\n// Re-assign process.exit because of commander\n// TODO: Switch to a different command framework\nprocess.exit = exit\n\nprogram\n\n    /**\n     * .version('0.0.1', '-v, --version')\n     * 1版本号<必须>,\n     * 2自定义标志<可省略>：默认为 -V 和 --version\n     * \n     * .option('-n, --name<path>', 'name description', 'default name')\n     * 1 自定义标志<必须>：分为长短标识，中间用逗号、竖线或者空格分割；标志后面可跟必须参数或可选参数，前者用 <> 包含，后者用 [] 包含\n     * 2 选项描述<省略不报错>：在使用 --help 命令时显示标志描述\n     * 3 默认值<可省略>\n     * \n     * .usage('[options] [dir]')\n     * 作用：只是打印用法说明\n     * \n     * .parse(process.argv)\n     * 作用：用于解析process.argv，设置options以及触发commands\n     * process.argv获取命令行参数\n     * \n     * \n     * Commander提供了api来取消未定义的option自动报错机制， .allowUnknownOption()\n     */\n    .version(version, '-v, --version')\n    .allowUnknownOption()\n    .usage('[options] [dir]')\n    .option('-f, --force', 'force on non-empty directory')\n    .parse(process.argv);\n\n// 没有退出时执行主函数\nif (!exit.exited) {\n    main();\n}\n\n/**\n * 主函数\n */\nfunction main() {\n    // 获取当前命令执行路径\n    var destinationPath = program.args.shift() || '.';\n    // 根据文件夹名称定义appname\n    // 用于package.json里的name\n    var appName = path.basename(path.resolve(destinationPath));\n\n    // 判断当前文件目录是否为空\n    emptyDirectory(destinationPath, function (empty) {\n        // 如果为空或者强制执行时，就直接生成项目\n        if (empty || program.force) {\n            createApplication(appName, destinationPath);\n        } else {\n            // 否则询问\n            confirm('当前文件夹不为空，是否继续？[y/N] ', function (ok) {\n                if (ok) {\n                        // 控制台不再输入时销毁\n                        process.stdin.destroy();\n                        createApplication(appName, destinationPath);\n                } else {\n                    console.error('aborting');\n                    exit(1);\n                }\n            });\n        }\n    })\n}\n\n/**\n * Check if the given directory `path` is empty.\n * 判断文件夹是否为空\n * @param {String} path\n * @param {Function} fn\n */\n\nfunction emptyDirectory(path, fn) {\n    fs.readdir(path, function (err, files) {\n        if (err && 'ENOENT' != err.code) throw err;\n        fn(!files || !files.length);\n    });\n}\n\n/**\n * 在给定路径中创建应用\n * @param {String} path\n */\n\nfunction createApplication(app_name, path) {\n    // wait的值等于complete函数执行的次数\n    // 用于选择在哪一次complete函数执行后执行控制台打印引导使用的文案\n    var wait = 1;\n    console.log();\n\n    function complete() {\n        if (--wait) return;\n        var prompt = launchedFromCmd() ? '>' : '$';\n\n        console.log();\n        console.log('   install dependencies:');\n        console.log('     %s cd %s && npm install', prompt, path);\n        console.log();\n        console.log('   run the app:');\n\n        // 根据控制台的环境不同打印不同文案（linux或者win）\n        if (launchedFromCmd()) {\n            console.log('     %s SET DEBUG=koa* & npm start', prompt, app_name);\n        } else {\n            console.log('     %s DEBUG=%s:* npm start', prompt, app_name);\n        }\n\n    }\n    copytmp(complete, path,app_name)\n\n}\n\n// 拷贝模拟里的文件到本地\nfunction copytmp(fn, destinationPath,app_name) {\n    // 获取模板文件的文件目录\n    tmpPath = path.join(__dirname, '..', 'template')\n    // 创建目录\n    fsm.ensureDir(destinationPath + '/'+app_name)\n        .then(() => {\n            // 拷贝模板\n            fsm.copy(tmpPath, destinationPath + '/'+app_name, err => {\n                if (err) return console.log(err)\n                fn()\n            })\n        })\n}\n/**\n * Determine if launched from cmd.exe\n * 判断控制台环境（liux或者win获取其他）\n */\n\nfunction launchedFromCmd() {\n    return process.platform === 'win32' &&\n        process.env._ === undefined;\n}\n\n\n/**\n * node是使用process.stdin和process.stdout来实现标准输入和输出的\n * readline 模块提供了一个接口，用于一次一行地读取可读流（例如 process.stdin）中的数据。 它可以使用以下方式访问：\n */\n\nvar rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n// 控制台问答\nfunction confirm(msg, callback) {\n    rl.question(msg, function (input) {\n        callback(/^y|yes|ok|true$/i.test(input));\n    });\n}\n\n// 控制台问答\nfunction wrieQuestion(msg, callback) {\n    rl.question(msg, function (input) {\n        // rl.close()后就不再监听控制台输入了\n        rl.close();\n        callback(input)\n    });\n}\n\n/**\n * 通过fs读取模板文件内容\n */\n\nfunction loadTemplate(name) {\n    return fs.readFileSync(path.join(__dirname, '..', 'template', name), 'utf-8');\n}\n\n/**\n * echo str > path.\n * 写入文件\n * @param {String} path\n * @param {String} str\n */\n\nfunction write(path, str, mode) {\n    fs.writeFileSync(path, str, { mode: mode || 0666 });\n    console.log('   \\x1b[36mcreate\\x1b[0m : ' + path);\n  }\n\n/**\n * 这里是主要解决在winodws上的一些bug，不用卡在这里，核心目的就是为了能让进程优雅退出\n * Graceful exit for async STDIO\n */\n\nfunction exit(code) {\n    // flush output for Node.js Windows pipe bug\n    // https://github.com/joyent/node/issues/6247 is just one bug example\n    // https://github.com/visionmedia/mocha/issues/333 has a good discussion\n    function done() {\n        if (!(draining--)) _exit(code);\n    }\n\n    var draining = 0;\n    var streams = [process.stdout, process.stderr];\n\n    exit.exited = true;\n\n    streams.forEach(function (stream) {\n        // submit empty write request and wait for completion\n        draining += 1;\n        stream.write('', done);\n    });\n\n    done();\n}\n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);