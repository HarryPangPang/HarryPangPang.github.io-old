(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{216:function(e,n,t){"use strict";t.r(n);var r=t(0),o=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("前端工程化至上")]),e._v(" "),t("p",[e._v("目录")]),e._v(" "),t("p",[e._v('版本说明\n目录结构\n初始化项目\nwebpack\nreact\n配置loader(sass,jsx)\n引入babel\n使用HtmlWebpackPlugin\n使用webpack-dev-server\n多入口页面配置\nref="http://www.imooc.com/article/details/id/291278#entry">如何理解entry point(bundle),chunk,module\n多入口页面html配置\nredux\n使用react-router\n使用redux-thunk\n模块热替换（Hot Module Replacement）\n使用ESLint\n使用axios和async/await\nCode Splitting\n使用CommonsChunkPlugin\n版本说明')]),e._v(" "),t("p",[e._v("由于构建相关例如webpack，babel，react-router等更新的较快，所以本文档以下面各种模块的版本号为主，各位安装的时候需要注意一下或者可以直接执行npm i将模块都安装好。")]),e._v(" "),t("p",[e._v('"dependencies": {\n"babel-core": "^6.26.3",\n"babel-eslint": "^8.2.3",\n"babel-loader": "^7.1.4",\n"babel-plugin-transform-async-to-generator": "^6.24.1",\n"babel-plugin-transform-runtime": "^6.23.0",\n"babel-preset-es2015": "^6.24.1",\n"babel-preset-react": "^6.24.1",\n"babel-preset-stage-0": "^6.24.1",\n"babel-preset-stage-3": "^6.24.1",\n"css-loader": "^0.28.11",\n"eslint": "^4.19.1",\n"eslint-loader": "^2.0.0",\n"eslint-plugin-react": "^7.9.1",\n"file-loader": "^1.1.11",\n"history": "^4.7.2",\n"html-webpack-plugin": "^3.2.0",\n"react": "^16.6.0",\n"react-dom": "^16.6.0",\n"react-hot-loader": "^4.3.12",\n"react-redux": "^6.0.0",\n"react-router": "^4.3.1",\n"react-router-dom": "^4.3.1",\n"redux": "^4.0.1",\n"sass-loader": "^7.0.3",\n"style-loader": "^0.21.0",\n"url-loader": "^1.0.1",\n"webpack": "^4.12.0",\n"webpack-cli": "^3.0.3",\n"webpack-dev-server": "^3.1.1"\n}\n目录结构')]),e._v(" "),t("p",[e._v("开发和发布版本的配置文件是分开的，多入口页面的目录结构。")]),e._v(" "),t("p",[e._v("react-family/\n|\n|──dist/                                    * 发布版本构建输出路径\n|\n|──dev/                                     * 调试版本构建输出路径\n|\n|──src/                                     * 工具函数\n|     |\n|     |—— component/                        * 各页面公用组件\n|     |\n|     |—— page/                             * 页面代码\n|     |      |—— index/                     * 页面代码\n|     |      |        |—— Main/             * 组件代码\n|     |      |        |       |—— Main.jsx  * 组件jsx\n|     |      |        |       |—— Main.scss * 组件css\n|     |      |\n|     |      |—— detail/                    * 页面代码\n|     |\n|     |—— static/                           * 静态文件js，css\n|\n|\n|──webpack.config.build.js                  * 发布版本使用的webpack配置文件\n|──webpack.config.dev.js                    * 调试版本使用的webpack配置文件\n|──.eslint                                  * eslint配置文件\n|__.babelrc                                 * babel配置文件\n初始化项目")]),e._v(" "),t("p",[e._v("创建文件夹\nmkdir react-family-bucket\n初始化npm\ncd react-family-bucket\nnpm init\n如果有特殊需要，可以填入自己的配置，一路回车下来，会生成一个package.json，里面是你项目的基本信息，后面的npm依赖安装也会配置在这里。")]),e._v(" "),t("p",[e._v("webpack")]),e._v(" "),t("p",[e._v("安装webpack\nnpm install webpack --save\nor\nnpm install webpack --g\n--save是将当前webpack安装到react-family-bucket下的/node_modules。")]),e._v(" "),t("p",[e._v("--g是将当前webpack安装到全局下面，可以在node的安装目录下找到全局的/node_modules。")]),e._v(" "),t("p",[e._v("配置webopack配置文件\ntouch webpack.config.dev.js\n新建一个app.js")]),e._v(" "),t("p",[e._v("touch app.js\n写入基本的webpack配置，可以参考这里：")]),e._v(" "),t("p",[e._v("const path = require('path');\nconst srcRoot = './src';\nmodule.exports = {")]),e._v(" "),t("pre",[t("code",[e._v("// 输入配置\nentry: [\n  './app.js'\n],,\n\n// 输出配置\noutput: {\n    path: path.resolve(__dirname, './dev'),\n\n    filename: 'bundle.min.js'\n},\n")])]),e._v(" "),t("p",[e._v("};\n3, 执行webpack命令\n如果是全局安装：")]),e._v(" "),t("p",[e._v("webpack --config webpack.config.dev.js\n如果是当前目录安装：")]),e._v(" "),t("p",[e._v("./node_modules/.bin/webpack --config webpack.config.dev.js\n在package.json中添加执行命令：")]),e._v(" "),t("p",[e._v('"scripts": {\n"dev": "./node_modules/.bin/webpack --config webpack.config.dev.js",\n},\n执行npm run dev命令之后，会发现需要安装webpack-cli，（webpack4之后需要安装这个）')]),e._v(" "),t("p",[e._v("npm install webpack-cli --save\n去除WARNING in configuration警告,在webpack.config.dev.js增加一个配置即可：")]),e._v(" "),t("p",[e._v("...\nmode: 'development'\n...\n成功之后会在dev下面生成bundle.min.js代表正常。")]),e._v(" "),t("p",[e._v("如果想要动态监听文件变化需要在命令后面添加 --watch")]),e._v(" "),t("p",[e._v("react")]),e._v(" "),t("p",[e._v("安装react\nnpm install react react-dom --save\n创建page目录和index页面文件：\nmkdir src\nmkdir page\ncd page\n创建index")]),e._v(" "),t("p",[e._v("mkdir index\ncd index & touch index.js & touch index.html\nindex.js")]),e._v(" "),t("p",[e._v("import ReactDom from 'react-dom';\nimport Main from './Main/Main.jsx';")]),e._v(" "),t("p",[e._v("ReactDom.render("),t("Main"),e._v(", document.getElementById('root'));\nindex.html")],1),e._v("\n<!DOCTYPE html>\n"),t("html",[t("head",[t("title",[e._v("index")]),e._v(" "),t("meta",{attrs:{charset:"utf-8"}}),e._v(" "),t("meta",{attrs:{name:"viewport",content:"width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"}})]),e._v(" "),t("body",[t("div",{attrs:{id:"root"}})])]),e._v(" "),t("p",[e._v("创建Main组件\nimport React from 'react';")]),e._v(" "),t("p",[e._v("class Main extends React.Component {")]),e._v(" "),t("pre",[t("code",[e._v("constructor(props) {\n    super(props);\n\n}\n\nrender() {\n\n    return (<div>Main</div>);\n}\n")])]),e._v(" "),t("p",[e._v("}")]),e._v(" "),t("p",[e._v("export default Main;")]),e._v(" "),t("p",[e._v("export 和 export default区别：")]),e._v(" "),t("p",[e._v("export可以有多个")]),e._v(" "),t("p",[e._v("xx.js:\nexport const test1 = 'a'\nexport function test2() {}")]),e._v(" "),t("p",[e._v("yy.js:\nimport { test1, test2 } from 'xx.js';\nexport default只能有1个")]),e._v(" "),t("p",[e._v("xx.js:\nlet test1 = 'a';\nexport default test1;")]),e._v(" "),t("p",[e._v("yy.js:\nimport test1 from 'xx.js';\nexport 和 module.exports\nlet exports = module.exports;\n修改webpack配置入口文件\nentry: [\npath.resolve(srcRoot,'./page/index/index.js')\n],\n配置loader")]),e._v(" "),t("p",[e._v("处理样式文件需要这些loader:\ncss-loader\nsass-loader\nstyle-loader")]),e._v(" "),t("p",[e._v("npm install css-loader sass-loader style-loader file-loader --save\n配置：")]),e._v(" "),t("p",[e._v("module: {\n// 加载器配置\nrules: [\n{ test: /.css$/, use: ['style-loader', 'css-loader'], include: path.resolve(srcRoot)},\n{ test: /.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'], include: path.resolve(srcRoot)}\n]\n},")]),e._v(" "),t("p",[e._v("url-loader处理处理静态文件\nnpm install url-loader --save")]),e._v(" "),t("p",[e._v("配置：")]),e._v(" "),t("pre",[t("code",[e._v("module: {\n    // 加载器配置\n    rules: [\n        { test: /\\.(png|jpg|jpeg)$/, use: 'url-loader?limit=8192&name=images/[name].[hash].[ext]', include: path.resolve(srcRoot)}\n    ]\n},\n")])]),e._v(" "),t("p",[e._v("limit:表示超过多少就使用base64来代替，单位是byte")]),e._v(" "),t("p",[e._v("name:可以设置图片的路径，名称和是否使用hash 具体参考这里")]),e._v(" "),t("p",[e._v("引入babel")]),e._v(" "),t("p",[e._v("bebel是用来解析es6语法或者是es7语法分解析器，让开发者能够使用新的es语法，同时支持jsx，vue等多种框架。")]),e._v(" "),t("p",[e._v("安装babel\nbabel-core\nbabel-loader\nnpm install babel-core babel-loader --save\n配置：")]),e._v(" "),t("p",[e._v("module: {\n// 加载器配置\nrules: [\n{ test: /.(js|jsx)$/, use: [{loader:'babel-loader'}] ,include: path.resolve(srcRoot)},\n]\n},\nbabel配置文件：.babelrc")]),e._v(" "),t("p",[e._v("touch .babelrc")]),e._v(" "),t("p",[e._v("配置：")]),e._v(" "),t("p",[e._v('{\n"presets": [\n"es2015",\n"react",\n"stage-0"\n],\n"plugins": []\n}\nbabel支持自定义的预设(presets)或插件(plugins),只有配置了这两个才能让babel生效，单独的安装babel是无意义的')]),e._v(" "),t("p",[e._v("presets：代表babel支持那种语法(就是你用那种语法写)，优先级是从下往上,state-0|1|2|..代表有很多没有列入标准的语法回已state-x表示,参考这里")]),e._v(" "),t("p",[e._v("plugins:代表babel解析的时候使用哪些插件，作用和presets类似，优先级是从上往下。\n依次安装：")]),e._v(" "),t("p",[e._v("babel-preset-es2015\nbabel-preset-react\nbabel-preset-stage-0")]),e._v(" "),t("p",[e._v("npm install babel-preset-es2015 babel-preset-react babel-preset-stage-0 --save\nbabel-polyfill是什么？")]),e._v(" "),t("p",[e._v("我们之前使用的babel，babel-loader 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。\nnpm install --save babel-polyfill\n使用：")]),e._v(" "),t("p",[e._v('import "babel-polyfill";\ntransform-runtime有什么区别？')]),e._v(" "),t("p",[e._v("当使用babel-polyfill时有一些问题：\n默认会引入所有babel支持的新语法，这样就会导致你的文件代码非常庞大。\n通过向全局对象和内置对象的prototype上添加方法来达成目的,造成全局变量污染。")]),e._v(" "),t("p",[e._v("这时就需要transform-runtime来帮我们有选择性的引入")]),e._v(" "),t("p",[e._v("npm install --save babel-plugin-transform-runtime\n配置文件：")]),e._v(" "),t("p",[e._v('{\n"plugins": [\n["transform-runtime", {\n"helpers": false,\n"polyfill": false,\n"regenerator": true,\n"moduleName": "babel-runtime"\n}]\n]\n}\n使用HtmlWebpackPlugin')]),e._v(" "),t("p",[e._v("记得我们之前新建的index.html么 我们执行构建命令之后并没有将index.html打包到dev目录下 我们需要HtmlWebpackPlugin来将我们output的js和html结合起来")]),e._v(" "),t("p",[e._v("npm install html-webpack-plugin --save\n配置：")]),e._v(" "),t("p",[e._v("const HtmlWebpackPlugin = require('html-webpack-plugin');\n...\nplugins: [\nnew HtmlWebpackPlugin({\nfilename: path.resolve(devPath, 'index.html'),\ntemplate: path.resolve(srcRoot, './page/index/index.html'),\n})\n]\nfilename:可以设置html输出的路径和文件名")]),e._v(" "),t("p",[e._v("template:可以设置已哪个html文件为模版\n更多参数配置可以参考这里")]),e._v(" "),t("p",[e._v("使用webpack-dev-server")]),e._v(" "),t("p",[e._v("webpack-dev-server是一个小型的Node.js Express服务器,它使用webpack-dev-middleware来服务于webpack的包。")]),e._v(" "),t("p",[e._v("安装\nnpm install webpack-dev-server --save\n修改在package.json中添加的执行命令：")]),e._v(" "),t("p",[e._v('"scripts": {\n"dev": "./node_modules/.bin/webpack-dev-server --config webpack.config.dev.js",\n},\n配置webpack配置文件：\ndevServer: {\n"contentBase": devPath,\n"compress": true,\n},\ncontentBase 表示server文件的根目录\ncompress 表示开启gzip\n更多的配置文档参考这里')]),e._v(" "),t("p",[e._v("webpack-dev-server默认情况下会将output的内容放在内存中，是看不到物理的文件的，如果想要看到物理的dev下面的文件可以安装write-file-webpack-plugin这个插件。\nwebpack-dev-server默认会开启livereload功能\ndevtool功能：")]),e._v(" "),t("p",[e._v("具体来说添加了devtool: 'inline-source-map'之后，利用source-map你在chrome控制台看到的source源码都是真正的源码，未压缩，未编译前的代码，没有添加，你看到的代码是真实的压缩过，编译过的代码，更多devtool的配置可以参考这里\n多入口文件配置")]),e._v(" "),t("p",[e._v("在之前的配置中，都是基于单入口页面配置的，entry和output只有一个文件，但是实际项目很多情况下是多页面的，在配置多页面时，有2中方法可以选择：")]),e._v(" "),t("p",[e._v("在entry入口配置时，传入对象而不是单独数组,output时利用[name]关键字来区分输出文件例如：\nentry: {\nindex: [path.resolve(srcRoot,'./page/index/index1.js'),path.resolve(srcRoot,'./page/index/index2.js')],\ndetail: path.resolve(srcRoot,'./page/detail/detail.js'),\nhome: path.resolve(srcRoot,'./page/home/home.js'),\n},\noutput: {\npath: path.resolve(__dirname, './dev'),")]),e._v(" "),t("pre",[t("code",[e._v("filename: '[name].min.js'\n")])]),e._v(" "),t("p",[e._v("},")]),e._v(" "),t("p",[e._v("通过node动态遍历需要entry point的目录，来动态生成entry：\nconst pageDir = path.resolve(srcRoot, 'page');\nfunction getEntry() {\nlet entryMap = {};")]),e._v(" "),t("pre",[t("code",[e._v("fs.readdirSync(pageDir).forEach((pathname)=>{\n    let fullPathName = path.resolve(pageDir, pathname);\n    let stat = fs.statSync(fullPathName);\n    let fileName = path.resolve(fullPathName, 'index.js');\n\n    if (stat.isDirectory() && fs.existsSync(fileName)) {\n        entryMap[pathname] = fileName;\n    }\n\n});\n\nreturn entryMap;\n")])]),e._v(" "),t("p",[e._v("}\n{\n...\nentry: getEntry()\n...\n}\n本demo采用的是第二中写法，能够更加灵活。")]),e._v(" "),t("p",[e._v("如何理解entry point(bundle),chunk,module")]),e._v(" "),t("p",[e._v("在webpack中，如何理解entry point(bundle),chunk,module?先看看下图：")]),e._v(" "),t("p",[e._v("根据图上的表述，我这里简单说一下结论：")]),e._v(" "),t("p",[e._v("配置中每个文件例如index1.js,index2.js,detail.js,home.js都属于entry point.\nentry这个配置中，每个key值,index,detail,home都相当于chunk。\n我们在代码中的require或者import的都属于module，这点很好理解。\nchunk的分类比较特别，有entry chunk,initial chunk,normal chunk,参考这个文章\n正常情况下，一个chunk对应一个output,在使用了CommonsChunkPlugin或者require.ensure之后，chunk就变成了initial chunk,normal chunk，这时，一个chunk对应多个output。")]),e._v(" "),t("p",[e._v("理解这些概念对于后续使用webpack插件有很大的帮助。\n多入口页面html配置")]),e._v(" "),t("p",[e._v("之前我们配置HtmlWebpackPlugin时，同样采用的是但页面的配置，这里我们将进行多页面改造,entryMap是上一步得到的entry：")]),e._v(" "),t("p",[e._v("function htmlAarray(entryMap) {\nlet htmlAarray = [];")]),e._v(" "),t("pre",[t("code",[e._v("Object.keys(entryMap).forEach(function(key){\n    let fullPathName = path.resolve(pageDir, key);\n    let fileName = path.resolve(fullPathName, key + '.html')\n    if (fs.existsSync(fileName)) {\n        htmlAarray.push(new HtmlWebpackPlugin({\n            chunks: key, // 注意这里的key就是chunk\n            filename: key + '.html',\n            template: fileName,\n            inlineSource:  '.(js|css)'\n        }))\n    }\n});\n\nreturn htmlAarray;\n")])]),e._v(" "),t("p",[e._v("}\n修改plugin配置：")]),e._v(" "),t("p",[e._v("plugins: [\n...\n].concat(htmlMap)\nredux")]),e._v(" "),t("p",[e._v("关于redux的使用可以参考阮一峰老师的入门教程")]),e._v(" "),t("p",[e._v("安装redux\nredux\nreact-redux\nnpm install redux react-redux --save\n新建reducers，actions目录和文件\n|—— index/"),t("br"),e._v("\n|—— Main/                   * 组件代码\n|       |—— Main.jsx        * 组件jsx\n|       |—— Main.scss       * 组件css\n|\n|—— actions/\n|       |—— actionTypes.js  * action常量\n|       |—— todoAction.js   * action\n|\n|—— reducers/\n|       |—— todoReducer.js  * reducer\n|       |—— main.js         * 将所有reducer进行combin，store.js只引入这个\n|\n|—— store.js\n|\n|—— index.js")]),e._v(" "),t("p",[e._v("修改代码，引入redux,这里以一个redux todo为demo例子：\nindex.js")]),e._v(" "),t("p",[e._v("import ReactDom from 'react-dom';\nimport React from 'react';\nimport Main from './Main/Main.jsx';\nimport store from './store.js';\nimport { Provider } from 'react-redux';")]),e._v(" "),t("p",[e._v("ReactDom.render(\n"),t("Provider",{attrs:{store:"{store}"}},[t("Main")],1),e._v("\n, document.getElementById('root'));\nstore.js")],1),e._v(" "),t("p",[e._v("import { createStore } from 'redux';\nimport todoReducer from './reducers/todoReducer.js';")]),e._v(" "),t("p",[e._v("const store = createStore(todoReducer);")]),e._v(" "),t("p",[e._v("export default store;\ntabReducer.js")]),e._v(" "),t("p",[e._v("import { ADD_TODO } from '../actions/actionTypes.js';")]),e._v(" "),t("p",[e._v("const initialState = {\ntodoList: []\n};")]),e._v(" "),t("p",[e._v("const addTodo = (state, action) => {")]),e._v(" "),t("p",[e._v("return { ...state, todoList: state.todoList.concat(action.obj) }\n}")]),e._v(" "),t("p",[e._v("const todoReducer = (state = initialState, action) => {\nswitch(action.type) {\ncase ADD_TODO: return addTodo(state, action);\ndefault: return state;\n}\n};\nexport default todoReducer;\nMain.jsx")]),e._v(" "),t("p",[e._v("import React from 'react';\nimport { connect } from 'react-redux';\nimport { addTodo } from '../actions/todoAction.js';")]),e._v(" "),t("p",[e._v("class Main extends React.Component {")]),e._v(" "),t("pre",[t("code",[e._v('onClick(){\n    let text = this.refs.input;\n\n    this.props.dispatch(addTodo({\n        text: text.value\n    }))\n}\nrender() {\n    return (\n        <div>\n            <input ref="input" type="text"></input>\n            <button onClick={()=>this.onClick()}>提交</button>\n            <ul>\n            {this.props.todoList.map((item, index)=>{\n                return <li key={index}>{item.text}</li>\n            })}\n            </ul>\n        </div>\n    );\n}\n')])]),e._v(" "),t("p",[e._v("}")]),e._v(" "),t("p",[e._v("export default connect(\nstate => ({\ntodoList: state.todoList\n})\n)(Main);\ntodoAction.js")]),e._v(" "),t("p",[e._v("import { ADD_TODO } from './actionTypes.js';")]),e._v(" "),t("p",[e._v("export const addTodo = (obj) => {\nreturn {\ntype: ADD_TODO,\nobj: obj\n};\n};\n使用react-router")]),e._v(" "),t("p",[e._v("react-router强大指出在于方便代码管理，结合redux使用更加强大，同时支持web，native更多参考这里")]),e._v(" "),t("p",[e._v("安装react-router-dom\nnpm install react-router-dom --save\n如果项目中用了redux，可以安装connected-react-router\nnpm install connected-react-router history --save")]),e._v(" "),t("p",[e._v("修改代码：")]),e._v(" "),t("p",[e._v("index.js:\nimport ReactDom from 'react-dom';\nimport React from 'react';\nimport Container from './Main/Container.jsx';\nimport { store, history } from './store.js';")]),e._v(" "),t("p",[e._v("import { Provider } from 'react-redux';")]),e._v(" "),t("p",[e._v("import { ConnectedRouter } from 'connected-react-router';")]),e._v(" "),t("p",[e._v("ReactDom.render(\n"),t("Provider",{attrs:{store:"{store}"}},[t("ConnectedRouter",{attrs:{history:"{history}"}},[t("Container")],1)],1),e._v("\n, document.getElementById('root'));\n结合history,react-router一共有3中不同的router：")],1),e._v(" "),t("p",[e._v("BrowserRouter通过history/createBrowserHistory引入:当切换时，url会动态更新，底层使用的时html5的pushState。\nHashRouter通过history/createHashHistory引入:当切换时，动态修改hash，利用hashchange事件。\nMemoryRouter通过history/createMemoryHistory引入:将路径，路由相关数据存入内存中，不涉及url相关更新，兼容性好。\n更多配置可以参考这里")]),e._v(" "),t("p",[e._v("如果想要在代码逻辑中获取当前的route的location信息需要在main.js中添加router的reducer:")]),e._v(" "),t("p",[e._v("新建main.js:\nimport { combineReducers } from 'redux';\nimport { connectRouter } from 'connected-react-router'\nimport todoReducer from './todoReducer.js';")]),e._v(" "),t("p",[e._v("const reducers = (history) => combineReducers({\ntodoReducer,\nrouter: connectRouter(history)\n});\nexport default reducers;\n编写store.js:")]),e._v(" "),t("p",[e._v("import { createStore } from 'redux';\nimport mainReducer from './reducers/main.js';\nimport createHistory from 'history/createHashHistory';")]),e._v(" "),t("p",[e._v("export const history = createHistory();")]),e._v(" "),t("p",[e._v("const store = createStore(\ncreateRootReducer(history),\n);")]),e._v(" "),t("p",[e._v("export default store;\n然后就可以在this.props.router里面获取到相关的location路径信息，其实就是将router对象放在组件的props里面。")]),e._v(" "),t("p",[e._v("如果需要自己通过dispatch一个action来触发router的跳转，需要引入routerMiddleware:\nimport { createStore,applyMiddleware,compose } from 'redux';\nimport mainReducer from './reducers/main.js';\nimport createHistory from 'history/createHashHistory';\nimport { routerMiddleware } from \"connected-react-router\";")]),e._v(" "),t("p",[e._v("export const history = createHistory();")]),e._v(" "),t("p",[e._v("const store = createStore(\ncreateRootReducer(history),\ncompose(applyMiddleware(routerMiddleware(history)))\n);")]),e._v(" "),t("p",[e._v("export default store;\n最后，将改动同步在index.js长这样：")]),e._v(" "),t("p",[e._v("index.js:")]),e._v(" "),t("p",[e._v("import ReactDom from 'react-dom';\nimport React from 'react';\nimport Container from './Main/Container.jsx';\nimport store, { history } from './store.js';")]),e._v(" "),t("p",[e._v("import { Provider } from 'react-redux';")]),e._v(" "),t("p",[e._v("import { ConnectedRouter } from 'connected-react-router';")]),e._v(" "),t("p",[e._v("ReactDom.render(\n"),t("Provider",{attrs:{store:"{store}"}},[t("ConnectedRouter",{attrs:{history:"{history}"}},[t("Container")],1)],1),e._v("\n, document.getElementById('root'));\n看到这里，大家可能会对react-router，react-router-dom，connected-react-router，history这些东西给搞晕了，在这里解释一下：")],1),e._v(" "),t("p",[e._v("react-router：是react-router的核心逻辑，并不涉及到UI，必须引入。\nreact-router-dom：是react-router的DOM绑定模块，只有用了react-router-dom才能用类似,这些组件，必须引入。\nhistory：是一个让你灵活控制或者模拟浏览器的历史操作的一个库，包括BrowserHistory，HashHistory，MemoryHistory，他可以脱离React使用，也可以结合React使用，可选引入。\nconnected-react-router：简单来说就是你的项目如果用的React和Redux，如果想要用router的话就可以引入connected-react-router，它能帮你把router的状态放在store里来管理(注意根据你使用的react-router版本不同，会使用不同的版本，它的前身是react-router-redux，官方已经不再维护了)，可选引入。\n使用Route和Link和withRouter:")]),e._v(" "),t("p",[e._v("先说说都是干嘛的：\nRoute:component里面的内容即是tab的主要内容，这个从react-router4开始生效：\n"),t("Route",{attrs:{exact:"",path:"/",component:"{Div1}"}}),e._v(" "),t("Route",{attrs:{path:"/2",component:"{Div2}"}}),e._v("\nLink:通常也可以用NavLink，相当于tab按钮，控制router的切换,activeClass表示当前tab处于激活态时应用上的class。\nwithRouter:如果你用了redux，那么你一定要引入它。\nexport default withRouter(connect(\nstate => ({\ntodoList: state.todoReducer.todoList\n})\n)(Main));\n如果你在使用hash时遇到Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack错误，可以将push改为replace即")],1),e._v(" "),t("NavLink",{attrs:{replace:"{true}",to:"/2",activeClassName:"selected"}},[e._v("切换到2号")]),e._v(" "),t("p",[e._v("设置初始化路由：\nBrowserRouter和HashRouter:\nconst history = createHistory();\nhistory.push('2');\nMemoryRouter:\nconst history = createMemoryHistory({\ninitialEntries: ['/2']\n});\n使用redux-thunk")]),e._v(" "),t("p",[e._v("redux-thunk 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过 fetch通用远程 API 这些场景，那么久应该使用 redux-thunk 了。redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响。")]),e._v(" "),t("p",[e._v("安装redux-thunk:\nnpm install redux-thunk --save\n修改store.js:\nimport { createStore,applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\nimport mainReducer from './reducers/main';\n...\nconst store = createStore(mainReducer, applyMiddleware(thunk));\n...\nexport default store;")]),e._v(" "),t("p",[e._v("在action.js使用redux-thunk：\nexport const getData = (obj) => (dispatch, getState) => {\nsetTimeout(()=>{\ndispatch({\ntype: GET_DATA,\nobj: obj\n});\n},1000);\n};\n模块热替换（Hot Module Replacement）")]),e._v(" "),t("p",[e._v("模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新,很高大上有木有！")]),e._v(" "),t("p",[e._v("下面说一下配置方法，它需要结合devServer使用：")]),e._v(" "),t("p",[e._v("devServer: {\nhot: true // 开启HMR\n},\n开启plugin：")]),e._v(" "),t("p",[e._v("const webpack = require('webpack');\nplugins: [\nnew webpack.NamedModulesPlugin(),\nnew webpack.HotModuleReplacementPlugin(),\n].concat(htmlMap)\n结合React一起使用：")]),e._v(" "),t("p",[e._v("安装react-hot-loader,\nnpm install react-hot-loader --save\n并新建一个Container.jsx:")]),e._v(" "),t("p",[e._v("import React from 'react';\nimport Main from './Main.jsx';\nimport { hot } from 'react-hot-loader'")]),e._v(" "),t("p",[e._v("class Container extends React.Component {")]),e._v(" "),t("pre",[t("code",[e._v("render() {\n    return <Main />\n}\n")])]),e._v(" "),t("p",[e._v("}\nexport default hot(module)(Container);\n结合redux：如果项目没有使用redux，可以无需配置后面2步")]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("修改store.js新增下面代码，为了让reducer也能实时热替换")])]),e._v(" "),t("p",[e._v("if (module.hot) {\nmodule.hot.accept('./reducers/todoReducer.js', () => {\nconst nextRootReducer = require('./reducers/todoReducer.js').default;\nstore.replaceReducer(nextRootReducer);\n});\n}")]),e._v(" "),t("p",[e._v("修改index.js\nimport ReactDom from 'react-dom';\nimport React from 'react';\nimport Container from './Main/Container.jsx';\nimport store from './store.js';")]),e._v(" "),t("p",[e._v("import { Provider } from 'react-redux';")]),e._v(" "),t("p",[e._v("ReactDom.render(\n"),t("Provider",{attrs:{store:"{store}"}},[t("Container")],1),e._v("\n, document.getElementById('root'));\n当控制台看到[WDS] Hot Module Replacement enabled.代表开启成功")],1),e._v(" "),t("p",[e._v("使用ESLint")]),e._v(" "),t("p",[e._v("ESLint 是众多 Javascript Linter 中的其中一种，其他比较常见的还有 JSLint 跟 JSHint，之所以用 ESLint 是因为他可以自由选择要使用哪些规则，也有很多现成的 plugin 可以使用，另外他对 ES6 还有 JSX 的支持程度跟其他 linter 相比之下也是最高的。")]),e._v(" "),t("p",[e._v("安装ESLint\nnpm install eslint eslint-loader babel-eslint --save\n其中eslint-loader是将webpack和eslint结合起来在webpack的配置文件中新增一个eslint-loader种，修改如下")]),e._v(" "),t("p",[e._v("{ test: /.(js|jsx)$/, use: [{loader:'babel-loader'},{loader:'eslint-loader'}] ,include: path.resolve(srcRoot)},\n新建.eslintrc配置文件,将parser配置成babel-eslint\n{\n\"extends\": [\"eslint:recommended\"],")]),e._v(" "),t("pre",[t("code",[e._v('"parser": "babel-eslint",\n\n"globals": {\n},\n"rules": {\n}\n')])]),e._v(" "),t("p",[e._v('}\n安装eslint-plugin-react:\nnpm install eslint-plugin-react --save\n说明一下，正常情况下每个eslint规则都是需要在rule下面配置，如果什么都不配置，其实本身eslint是不生效的。\neslint本身有很多默认的规则模版，可以通过extends来配置，默认可以使用eslint:recommended。\n在使用react开发时可以安装eslint-plugin-react来告知使用react专用的规则来lint\n修改.eslintrc配置文件,增加rules，更多rules配置可以参考这里\n{\n"extends": ["eslint:recommended","plugin:react/recommended"],')]),e._v(" "),t("pre",[t("code",[e._v('"parser": "babel-eslint",\n\n"globals": {\n    "window": true,\n    "document": true,\n    "module": true,\n    "require": true\n},\n"rules": {\n    "react/prop-types" : "off",\n    "no-console" : "off"\n}\n')])]),e._v(" "),t("p",[e._v("}\n使用axios和async/await")]),e._v(" "),t("p",[e._v("axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端：")]),e._v(" "),t("p",[e._v("从浏览器中创建 XMLHttpRequest\n从 node.js 发出 http 请求\n支持 Promise API\n自动转换JSON数据\n安装axios:\nnpm install axios --save\n在action中使用axios：\nimport axios from 'axios';\nexport const getData = (obj) => (dispatch, getState) => {\naxios.get('/json/comments.json').then((resp)=>{\ndispatch({\ntype: GET_DATA,\nobj: resp\n});\n});\n};\nasync/await：")]),e._v(" "),t("p",[e._v("Javascript的回调地狱，相信很多人都知道，尤其是在node端，近些年比较流行的是Promise的解决方案，但是随着 Node 7 的发布，编程终级解决方案的 async/await应声而出。")]),e._v(" "),t("p",[e._v("function resolveAfter2Seconds() {\nreturn new Promise(resolve => {\nsetTimeout(() => {\nresolve('resolved');\n}, 2000);\n});\n}")]),e._v(" "),t("p",[e._v("async function asyncCall() {\nvar result = await resolveAfter2Seconds();\n}")]),e._v(" "),t("p",[e._v("asyncCall();\nasync/await的用途是简化使用 promises 异步调用的操作，并对一组 Promises执行某些操作。await前提是方法返回的是一个Promise对象，正如Promises类似于结构化回调，async/await类似于组合生成器和 promises。")]),e._v(" "),t("p",[e._v('async/await需要安装babel-plugin-transform-async-to-generator。\nnpm install babel-plugin-transform-async-to-generator --save\n在.babelrc中增加配置：\n"plugins": [\n"transform-async-to-generator"\n]\n这样做仅仅是将async转换generator，如果你当前的浏览器不支持generator，你将会收到一个Uncaught ReferenceError: regeneratorRuntime is not defined的错误，你需要：')]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("安装babel-plugin-transform-runtime:")])]),e._v(" "),t("p",[e._v('npm install babel-plugin-transform-async-to-generator --save\n修改.babelrc中的配置(可以去掉之前配置的transform-async-to-generator)：\n"plugins": [\n"transform-runtime"\n]\n如果不想引入所有的polyfill(参考上面对babel的解释),可以增加配置：\n"plugins": [\n"transform-runtime",\n{\n"polyfill": false,')]),e._v(" "),t("pre",[t("code",[e._v('            "regenerator": true,\n        }\n]\n')])]),e._v(" "),t("p",[e._v("结合axios使用：\nimport axios from 'axios';\nexport const getData = (obj) => async (dispatch, getState) => {\nlet resp = axios.get('/json/comments.json');\ndispatch({\ntype: GET_DATA,\nobj: resp\n});\n};\nCode Splitting")]),e._v(" "),t("p",[e._v("对于webpack1，2之前，你可以使用require.ensure来控制一个组件的懒加载：\nrequire.ensure([], _require => {\nlet Component = _require('./Component.jsx');\n},'lazyname')\n在webpack4中，官方已经不再推荐使用require.ensure来使用懒加载功能Dynamic Imports，取而代之的是ES6的import()方法：\nimport(\n/* webpackChunkName: \"my-chunk-name\" "),t("em",[e._v("/\n/")]),e._v(" webpackMode: \"lazy\" */\n'module'\n);\n不小小看注释里的代码，webpack在打包时会动态识别这里的代码来做相关的配置，例如chunk name等等。\n3. Prefetching/Preloading modules:")]),e._v(" "),t("p",[e._v("webpack 4.6.0+支持了Prefetching/Preloading的写法:")]),e._v(" "),t("p",[e._v("//...\nimport(/* webpackPreload: true */ 'ChartingLibrary');\n结合React-Router使用:\nreact-loadable对上述的功能做了封装，丰富了一些功能，结合React-Router起来使用更加方便。")]),e._v(" "),t("p",[e._v("npm install react-loadable --save\n在react-router里使用：")]),e._v(" "),t("p",[e._v("function Loading() {\nreturn ")]),t("div",[e._v("Loading...")]),e._v(";\n}"),t("p"),e._v(" "),t("p",[e._v("let Div2 = Loadable({\nloader: () => import('./Div2'),\nloading: Loading,\n});")]),e._v(" "),t("Route",{attrs:{path:"/2",component:"{Div2}"}}),e._v(" "),t("p",[e._v("使用CommonsChunkPlugin")]),e._v(" "),t("p",[e._v("CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。")]),e._v(" "),t("p",[e._v("在webpack4之前的用法：\nnew webpack.optimize.CommonsChunkPlugin({\nname: 'common',\nchunks: ['page1','page2'],\nminChunks: 3\n})\nname: string: 提出出的名称\nchunks: string[]: webpack会从传入的chunk里面提取公共代码,默认从所有entry里提取\nminChunks: number|infinity|function(module,count)->boolean: 如果传入数字或infinity(默认值为3)，就是告诉webpack，只有当模块重复的次数大于等于该数字时，这个模块才会被提取出来。当传入为函数时，所有符合条件的chunk中的模块都会被传入该函数做计算，返回true的模块会被提取到目标chunk。\n更多的参数配置，可以参考这里\n在webpack4之后的用法：\nmodule.exports = {\n//...\noptimization: {\nsplitChunks: {\nchunks: 'async',\nminSize: 30000,\nminChunks: 1,\nmaxAsyncRequests: 5,\nmaxInitialRequests: 3,\nautomaticNameDelimiter: '~',\nname: true,\ncacheGroups: {\nvendors: {\ntest: /[\\/]node_modules[\\/]/,\npriority: -10\n},\ndefault: {\nminChunks: 2,\npriority: -20,\nreuseExistingChunk: true\n}\n}\n}\n}\n};\nsplitChunks: 配置一个分离chunk(代替老版本的CommonsChunkPlugin)\ncacheGroups: 自定义配置主要使用它来决定生成的文件:\ntest: 限制范围\nname: 生成文件名\npriority: 优先级\nminSize: number: 最小尺寸必须大于此值，默认30000B\nminChunks: 其他entry引用次数大于此值，默认1\nmaxInitialRequests: entry文件请求的chunks不应该超过此值（请求过多，耗时）\nmaxAsyncRequests: 异步请求的chunks不应该超过此值\nautomaticNameDelimiter: 自动命名连接符\nchunks: 值为\"initial\", “async”（默认） 或 “all”:\ninitial: 入口chunk，对于异步导入的文件不处理\nasync: 异步chunk，只对异步导入的文件处理\nall: 全部chunk")])],1)}),[],!1,null,null,null);n.default=o.exports}}]);