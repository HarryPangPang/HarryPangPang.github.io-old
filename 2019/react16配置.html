<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Harry&#39;s Blog</title>
    <meta name="description" content="Just playing around">
    
    
    <link rel="preload" href="/assets/css/0.styles.c7d45e2d.css" as="style"><link rel="preload" href="/assets/js/app.4498c43d.js" as="script"><link rel="preload" href="/assets/js/2.b4182e24.js" as="script"><link rel="preload" href="/assets/js/17.ead69c87.js" as="script"><link rel="prefetch" href="/assets/js/10.ec7a14d1.js"><link rel="prefetch" href="/assets/js/11.68fd43cd.js"><link rel="prefetch" href="/assets/js/12.cb531b98.js"><link rel="prefetch" href="/assets/js/13.2117fb4d.js"><link rel="prefetch" href="/assets/js/14.95f820b4.js"><link rel="prefetch" href="/assets/js/15.ff37cb81.js"><link rel="prefetch" href="/assets/js/16.f94e9052.js"><link rel="prefetch" href="/assets/js/18.517dd641.js"><link rel="prefetch" href="/assets/js/19.17d14f38.js"><link rel="prefetch" href="/assets/js/20.5bfc367a.js"><link rel="prefetch" href="/assets/js/21.c1220b6f.js"><link rel="prefetch" href="/assets/js/22.d47ea806.js"><link rel="prefetch" href="/assets/js/23.68f3d4b0.js"><link rel="prefetch" href="/assets/js/24.e95df7f3.js"><link rel="prefetch" href="/assets/js/25.d985f29f.js"><link rel="prefetch" href="/assets/js/26.c08cf248.js"><link rel="prefetch" href="/assets/js/27.d84cca50.js"><link rel="prefetch" href="/assets/js/28.bb4c1ed9.js"><link rel="prefetch" href="/assets/js/29.2003a480.js"><link rel="prefetch" href="/assets/js/3.48e27743.js"><link rel="prefetch" href="/assets/js/30.0e921be7.js"><link rel="prefetch" href="/assets/js/31.bb5d9ed1.js"><link rel="prefetch" href="/assets/js/32.867850a9.js"><link rel="prefetch" href="/assets/js/33.0cf47229.js"><link rel="prefetch" href="/assets/js/34.554d5707.js"><link rel="prefetch" href="/assets/js/35.440ad71c.js"><link rel="prefetch" href="/assets/js/36.4a230733.js"><link rel="prefetch" href="/assets/js/37.8a4e5515.js"><link rel="prefetch" href="/assets/js/38.6fe7e942.js"><link rel="prefetch" href="/assets/js/39.3b9a3c19.js"><link rel="prefetch" href="/assets/js/4.2d108d05.js"><link rel="prefetch" href="/assets/js/40.fdee5b5a.js"><link rel="prefetch" href="/assets/js/41.0bc34dad.js"><link rel="prefetch" href="/assets/js/42.58f9d475.js"><link rel="prefetch" href="/assets/js/43.bec9e558.js"><link rel="prefetch" href="/assets/js/44.2bf75316.js"><link rel="prefetch" href="/assets/js/45.0d25d3f1.js"><link rel="prefetch" href="/assets/js/46.349a7be1.js"><link rel="prefetch" href="/assets/js/47.16c0ae27.js"><link rel="prefetch" href="/assets/js/48.d33184cd.js"><link rel="prefetch" href="/assets/js/49.71831286.js"><link rel="prefetch" href="/assets/js/5.c199e918.js"><link rel="prefetch" href="/assets/js/50.47b4afbd.js"><link rel="prefetch" href="/assets/js/51.a263a6a6.js"><link rel="prefetch" href="/assets/js/52.bb922985.js"><link rel="prefetch" href="/assets/js/6.85c03d0d.js"><link rel="prefetch" href="/assets/js/7.62c90daa.js"><link rel="prefetch" href="/assets/js/8.d4044af7.js"><link rel="prefetch" href="/assets/js/9.3beb6d47.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c7d45e2d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Harry's Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>2020年博客</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js忍者秘籍读书笔记</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>python基础学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javascript设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>过去的博客</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/2019/10个前端面试必会题.html" class="sidebar-link">10个前端面试必会题目！（适用于中高级）</a></li><li><a href="/2019/201901面试题分享.html" class="sidebar-link">201901面试题分享</a></li><li><a href="/2019/常用的一些git命令行.html" class="sidebar-link">常用的一些git命令行</a></li><li><a href="/2019/发布流程.html" class="sidebar-link">发布流程</a></li><li><a href="/2019/函数节流与防抖.html" class="sidebar-link">函数节流与防抖</a></li><li><a href="/2019/函数柯里化.html" class="sidebar-link">函数柯里化（curry)</a></li><li><a href="/2019/函数声明VS函数表达式.html" class="sidebar-link">函数声明？函数表达式？我该怎么选？！</a></li><li><a href="/2019/看懂js中this关键字的指向问题.html" class="sidebar-link">看懂js中this关键字的指向问题</a></li><li><a href="/2019/浏览器缓存的了解.html" class="sidebar-link">浏览器缓存的了解</a></li><li><a href="/2019/前端进阶学习路径.html" class="sidebar-link">前端进阶学习路径</a></li><li><a href="/2019/前端知识点190111.html" class="sidebar-link">前端知识点1901</a></li><li><a href="/2019/强制缓存（200）和协商缓存（304）.html" class="sidebar-link">强制缓存（200）和协商缓存（304）</a></li><li><a href="/2019/如何理解es6中的class以及class中的constructor函数.html" class="sidebar-link">如何理解es6中的class以及class中的constructor函数</a></li><li><a href="/2019/如何让小孩学习javascript.html" class="sidebar-link">如何让小孩学习javascript</a></li><li><a href="/2019/十分钟了解ajax.html" class="sidebar-link">十分钟了解ajax</a></li><li><a href="/2019/是时候谈谈JavaScript面向对象了.html" class="sidebar-link">是时候谈谈JavaScript面向对象了</a></li><li><a href="/2019/手把手教你实现脚手架工具Koa-generator.html" class="sidebar-link">手把手教你实现脚手架工具Koa-generator</a></li><li><a href="/2019/HTTP请求的四种方式区别.html" class="sidebar-link">HTTP请求的四种方式区别</a></li><li><a href="/2019/javascript-闭包.html" class="sidebar-link">javascript-闭包</a></li><li><a href="/2019/Javascript常见的内存泄漏.html" class="sidebar-link">Javascript常见的内存泄漏</a></li><li><a href="/2019/javascript跨域.html" class="sidebar-link">javascript跨域</a></li><li><a href="/2019/JavaScript执行环境-执行栈.html" class="sidebar-link">JavaScript执行环境-执行栈</a></li><li><a href="/2019/MySQL8-0-12-secure-file-priv数据导出问题解决.html" class="sidebar-link">MySQL8.0.12--secure-file-priv数据导出问题解决</a></li><li><a href="/2019/React_V16入门手册.html" class="sidebar-link">React_V16入门手册</a></li><li><a href="/2019/react16配置.html" class="active sidebar-link">/2019/react16配置.html</a></li><li><a href="/2019/react生命周期.html" class="sidebar-link">react生命周期</a></li><li><a href="/2019/React虚拟dom和diff算法.html" class="sidebar-link">React虚拟dom和diff算法</a></li><li><a href="/2019/React学习笔记.html" class="sidebar-link">React学习笔记</a></li><li><a href="/2019/Vue使用踩坑记录.html" class="sidebar-link">Vue使用踩坑记录</a></li><li><a href="/2019/vue中AsyncAwait的使用示例.html" class="sidebar-link">vue中AsyncAwait的使用示例</a></li><li><a href="/2019/webpack下build报错.html" class="sidebar-link">webpack下build报错</a></li><li><a href="/2019/zabbix平台搭建.html" class="sidebar-link">zabbix平台搭建</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>others</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>前端工程化至上</p> <p>目录</p> <p>版本说明
目录结构
初始化项目
webpack
react
配置loader(sass,jsx)
引入babel
使用HtmlWebpackPlugin
使用webpack-dev-server
多入口页面配置
ref=&quot;http://www.imooc.com/article/details/id/291278#entry&quot;&gt;如何理解entry point(bundle),chunk,module
多入口页面html配置
redux
使用react-router
使用redux-thunk
模块热替换（Hot Module Replacement）
使用ESLint
使用axios和async/await
Code Splitting
使用CommonsChunkPlugin
版本说明</p> <p>由于构建相关例如webpack，babel，react-router等更新的较快，所以本文档以下面各种模块的版本号为主，各位安装的时候需要注意一下或者可以直接执行npm i将模块都安装好。</p> <p>&quot;dependencies&quot;: {
&quot;babel-core&quot;: &quot;^6.26.3&quot;,
&quot;babel-eslint&quot;: &quot;^8.2.3&quot;,
&quot;babel-loader&quot;: &quot;^7.1.4&quot;,
&quot;babel-plugin-transform-async-to-generator&quot;: &quot;^6.24.1&quot;,
&quot;babel-plugin-transform-runtime&quot;: &quot;^6.23.0&quot;,
&quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,
&quot;babel-preset-react&quot;: &quot;^6.24.1&quot;,
&quot;babel-preset-stage-0&quot;: &quot;^6.24.1&quot;,
&quot;babel-preset-stage-3&quot;: &quot;^6.24.1&quot;,
&quot;css-loader&quot;: &quot;^0.28.11&quot;,
&quot;eslint&quot;: &quot;^4.19.1&quot;,
&quot;eslint-loader&quot;: &quot;^2.0.0&quot;,
&quot;eslint-plugin-react&quot;: &quot;^7.9.1&quot;,
&quot;file-loader&quot;: &quot;^1.1.11&quot;,
&quot;history&quot;: &quot;^4.7.2&quot;,
&quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,
&quot;react&quot;: &quot;^16.6.0&quot;,
&quot;react-dom&quot;: &quot;^16.6.0&quot;,
&quot;react-hot-loader&quot;: &quot;^4.3.12&quot;,
&quot;react-redux&quot;: &quot;^6.0.0&quot;,
&quot;react-router&quot;: &quot;^4.3.1&quot;,
&quot;react-router-dom&quot;: &quot;^4.3.1&quot;,
&quot;redux&quot;: &quot;^4.0.1&quot;,
&quot;sass-loader&quot;: &quot;^7.0.3&quot;,
&quot;style-loader&quot;: &quot;^0.21.0&quot;,
&quot;url-loader&quot;: &quot;^1.0.1&quot;,
&quot;webpack&quot;: &quot;^4.12.0&quot;,
&quot;webpack-cli&quot;: &quot;^3.0.3&quot;,
&quot;webpack-dev-server&quot;: &quot;^3.1.1&quot;
}
目录结构</p> <p>开发和发布版本的配置文件是分开的，多入口页面的目录结构。</p> <p>react-family/
|
|──dist/                                    * 发布版本构建输出路径
|
|──dev/                                     * 调试版本构建输出路径
|
|──src/                                     * 工具函数
|     |
|     |—— component/                        * 各页面公用组件
|     |
|     |—— page/                             * 页面代码
|     |      |—— index/                     * 页面代码
|     |      |        |—— Main/             * 组件代码
|     |      |        |       |—— Main.jsx  * 组件jsx
|     |      |        |       |—— Main.scss * 组件css
|     |      |
|     |      |—— detail/                    * 页面代码
|     |
|     |—— static/                           * 静态文件js，css
|
|
|──webpack.config.build.js                  * 发布版本使用的webpack配置文件
|──webpack.config.dev.js                    * 调试版本使用的webpack配置文件
|──.eslint                                  * eslint配置文件
|__.babelrc                                 * babel配置文件
初始化项目</p> <p>创建文件夹
mkdir react-family-bucket
初始化npm
cd react-family-bucket
npm init
如果有特殊需要，可以填入自己的配置，一路回车下来，会生成一个package.json，里面是你项目的基本信息，后面的npm依赖安装也会配置在这里。</p> <p>webpack</p> <p>安装webpack
npm install webpack --save
or
npm install webpack --g
--save是将当前webpack安装到react-family-bucket下的/node_modules。</p> <p>--g是将当前webpack安装到全局下面，可以在node的安装目录下找到全局的/node_modules。</p> <p>配置webopack配置文件
touch webpack.config.dev.js
新建一个app.js</p> <p>touch app.js
写入基本的webpack配置，可以参考这里：</p> <p>const path = require('path');
const srcRoot = './src';
module.exports = {</p> <pre><code>// 输入配置
entry: [
  './app.js'
],,

// 输出配置
output: {
    path: path.resolve(__dirname, './dev'),

    filename: 'bundle.min.js'
},
</code></pre> <p>};
3, 执行webpack命令
如果是全局安装：</p> <p>webpack --config webpack.config.dev.js
如果是当前目录安装：</p> <p>./node_modules/.bin/webpack --config webpack.config.dev.js
在package.json中添加执行命令：</p> <p>&quot;scripts&quot;: {
&quot;dev&quot;: &quot;./node_modules/.bin/webpack --config webpack.config.dev.js&quot;,
},
执行npm run dev命令之后，会发现需要安装webpack-cli，（webpack4之后需要安装这个）</p> <p>npm install webpack-cli --save
去除WARNING in configuration警告,在webpack.config.dev.js增加一个配置即可：</p> <p>...
mode: 'development'
...
成功之后会在dev下面生成bundle.min.js代表正常。</p> <p>如果想要动态监听文件变化需要在命令后面添加 --watch</p> <p>react</p> <p>安装react
npm install react react-dom --save
创建page目录和index页面文件：
mkdir src
mkdir page
cd page
创建index</p> <p>mkdir index
cd index &amp; touch index.js &amp; touch index.html
index.js</p> <p>import ReactDom from 'react-dom';
import Main from './Main/Main.jsx';</p> <p>ReactDom.render(<Main></Main>, document.getElementById('root'));
index.html</p>
&lt;!DOCTYPE html&gt;
<html><head><title>index</title> <meta charset="utf-8"> <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"></head> <body><div id="root"></div></body></html> <p>创建Main组件
import React from 'react';</p> <p>class Main extends React.Component {</p> <pre><code>constructor(props) {
    super(props);

}

render() {

    return (&lt;div&gt;Main&lt;/div&gt;);
}
</code></pre> <p>}</p> <p>export default Main;</p> <p>export 和 export default区别：</p> <p>export可以有多个</p> <p>xx.js:
export const test1 = 'a'
export function test2() {}</p> <p>yy.js:
import { test1, test2 } from 'xx.js';
export default只能有1个</p> <p>xx.js:
let test1 = 'a';
export default test1;</p> <p>yy.js:
import test1 from 'xx.js';
export 和 module.exports
let exports = module.exports;
修改webpack配置入口文件
entry: [
path.resolve(srcRoot,'./page/index/index.js')
],
配置loader</p> <p>处理样式文件需要这些loader:
css-loader
sass-loader
style-loader</p> <p>npm install css-loader sass-loader style-loader file-loader --save
配置：</p> <p>module: {
// 加载器配置
rules: [
{ test: /.css$/, use: ['style-loader', 'css-loader'], include: path.resolve(srcRoot)},
{ test: /.scss$/, use: ['style-loader', 'css-loader', 'sass-loader'], include: path.resolve(srcRoot)}
]
},</p> <p>url-loader处理处理静态文件
npm install url-loader --save</p> <p>配置：</p> <pre><code>module: {
    // 加载器配置
    rules: [
        { test: /\.(png|jpg|jpeg)$/, use: 'url-loader?limit=8192&amp;name=images/[name].[hash].[ext]', include: path.resolve(srcRoot)}
    ]
},
</code></pre> <p>limit:表示超过多少就使用base64来代替，单位是byte</p> <p>name:可以设置图片的路径，名称和是否使用hash 具体参考这里</p> <p>引入babel</p> <p>bebel是用来解析es6语法或者是es7语法分解析器，让开发者能够使用新的es语法，同时支持jsx，vue等多种框架。</p> <p>安装babel
babel-core
babel-loader
npm install babel-core babel-loader --save
配置：</p> <p>module: {
// 加载器配置
rules: [
{ test: /.(js|jsx)$/, use: [{loader:'babel-loader'}] ,include: path.resolve(srcRoot)},
]
},
babel配置文件：.babelrc</p> <p>touch .babelrc</p> <p>配置：</p> <p>{
&quot;presets&quot;: [
&quot;es2015&quot;,
&quot;react&quot;,
&quot;stage-0&quot;
],
&quot;plugins&quot;: []
}
babel支持自定义的预设(presets)或插件(plugins),只有配置了这两个才能让babel生效，单独的安装babel是无意义的</p> <p>presets：代表babel支持那种语法(就是你用那种语法写)，优先级是从下往上,state-0|1|2|..代表有很多没有列入标准的语法回已state-x表示,参考这里</p> <p>plugins:代表babel解析的时候使用哪些插件，作用和presets类似，优先级是从上往下。
依次安装：</p> <p>babel-preset-es2015
babel-preset-react
babel-preset-stage-0</p> <p>npm install babel-preset-es2015 babel-preset-react babel-preset-stage-0 --save
babel-polyfill是什么？</p> <p>我们之前使用的babel，babel-loader 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译。如果想使用这些新的对象和方法，必须使用 babel-polyfill，为当前环境提供一个垫片。
npm install --save babel-polyfill
使用：</p> <p>import &quot;babel-polyfill&quot;;
transform-runtime有什么区别？</p> <p>当使用babel-polyfill时有一些问题：
默认会引入所有babel支持的新语法，这样就会导致你的文件代码非常庞大。
通过向全局对象和内置对象的prototype上添加方法来达成目的,造成全局变量污染。</p> <p>这时就需要transform-runtime来帮我们有选择性的引入</p> <p>npm install --save babel-plugin-transform-runtime
配置文件：</p> <p>{
&quot;plugins&quot;: [
[&quot;transform-runtime&quot;, {
&quot;helpers&quot;: false,
&quot;polyfill&quot;: false,
&quot;regenerator&quot;: true,
&quot;moduleName&quot;: &quot;babel-runtime&quot;
}]
]
}
使用HtmlWebpackPlugin</p> <p>记得我们之前新建的index.html么 我们执行构建命令之后并没有将index.html打包到dev目录下 我们需要HtmlWebpackPlugin来将我们output的js和html结合起来</p> <p>npm install html-webpack-plugin --save
配置：</p> <p>const HtmlWebpackPlugin = require('html-webpack-plugin');
...
plugins: [
new HtmlWebpackPlugin({
filename: path.resolve(devPath, 'index.html'),
template: path.resolve(srcRoot, './page/index/index.html'),
})
]
filename:可以设置html输出的路径和文件名</p> <p>template:可以设置已哪个html文件为模版
更多参数配置可以参考这里</p> <p>使用webpack-dev-server</p> <p>webpack-dev-server是一个小型的Node.js Express服务器,它使用webpack-dev-middleware来服务于webpack的包。</p> <p>安装
npm install webpack-dev-server --save
修改在package.json中添加的执行命令：</p> <p>&quot;scripts&quot;: {
&quot;dev&quot;: &quot;./node_modules/.bin/webpack-dev-server --config webpack.config.dev.js&quot;,
},
配置webpack配置文件：
devServer: {
&quot;contentBase&quot;: devPath,
&quot;compress&quot;: true,
},
contentBase 表示server文件的根目录
compress 表示开启gzip
更多的配置文档参考这里</p> <p>webpack-dev-server默认情况下会将output的内容放在内存中，是看不到物理的文件的，如果想要看到物理的dev下面的文件可以安装write-file-webpack-plugin这个插件。
webpack-dev-server默认会开启livereload功能
devtool功能：</p> <p>具体来说添加了devtool: 'inline-source-map'之后，利用source-map你在chrome控制台看到的source源码都是真正的源码，未压缩，未编译前的代码，没有添加，你看到的代码是真实的压缩过，编译过的代码，更多devtool的配置可以参考这里
多入口文件配置</p> <p>在之前的配置中，都是基于单入口页面配置的，entry和output只有一个文件，但是实际项目很多情况下是多页面的，在配置多页面时，有2中方法可以选择：</p> <p>在entry入口配置时，传入对象而不是单独数组,output时利用[name]关键字来区分输出文件例如：
entry: {
index: [path.resolve(srcRoot,'./page/index/index1.js'),path.resolve(srcRoot,'./page/index/index2.js')],
detail: path.resolve(srcRoot,'./page/detail/detail.js'),
home: path.resolve(srcRoot,'./page/home/home.js'),
},
output: {
path: path.resolve(__dirname, './dev'),</p> <pre><code>filename: '[name].min.js'
</code></pre> <p>},</p> <p>通过node动态遍历需要entry point的目录，来动态生成entry：
const pageDir = path.resolve(srcRoot, 'page');
function getEntry() {
let entryMap = {};</p> <pre><code>fs.readdirSync(pageDir).forEach((pathname)=&gt;{
    let fullPathName = path.resolve(pageDir, pathname);
    let stat = fs.statSync(fullPathName);
    let fileName = path.resolve(fullPathName, 'index.js');

    if (stat.isDirectory() &amp;&amp; fs.existsSync(fileName)) {
        entryMap[pathname] = fileName;
    }

});

return entryMap;
</code></pre> <p>}
{
...
entry: getEntry()
...
}
本demo采用的是第二中写法，能够更加灵活。</p> <p>如何理解entry point(bundle),chunk,module</p> <p>在webpack中，如何理解entry point(bundle),chunk,module?先看看下图：</p> <p>根据图上的表述，我这里简单说一下结论：</p> <p>配置中每个文件例如index1.js,index2.js,detail.js,home.js都属于entry point.
entry这个配置中，每个key值,index,detail,home都相当于chunk。
我们在代码中的require或者import的都属于module，这点很好理解。
chunk的分类比较特别，有entry chunk,initial chunk,normal chunk,参考这个文章
正常情况下，一个chunk对应一个output,在使用了CommonsChunkPlugin或者require.ensure之后，chunk就变成了initial chunk,normal chunk，这时，一个chunk对应多个output。</p> <p>理解这些概念对于后续使用webpack插件有很大的帮助。
多入口页面html配置</p> <p>之前我们配置HtmlWebpackPlugin时，同样采用的是但页面的配置，这里我们将进行多页面改造,entryMap是上一步得到的entry：</p> <p>function htmlAarray(entryMap) {
let htmlAarray = [];</p> <pre><code>Object.keys(entryMap).forEach(function(key){
    let fullPathName = path.resolve(pageDir, key);
    let fileName = path.resolve(fullPathName, key + '.html')
    if (fs.existsSync(fileName)) {
        htmlAarray.push(new HtmlWebpackPlugin({
            chunks: key, // 注意这里的key就是chunk
            filename: key + '.html',
            template: fileName,
            inlineSource:  '.(js|css)'
        }))
    }
});

return htmlAarray;
</code></pre> <p>}
修改plugin配置：</p> <p>plugins: [
...
].concat(htmlMap)
redux</p> <p>关于redux的使用可以参考阮一峰老师的入门教程</p> <p>安装redux
redux
react-redux
npm install redux react-redux --save
新建reducers，actions目录和文件
|—— index/<br>
|—— Main/                   * 组件代码
|       |—— Main.jsx        * 组件jsx
|       |—— Main.scss       * 组件css
|
|—— actions/
|       |—— actionTypes.js  * action常量
|       |—— todoAction.js   * action
|
|—— reducers/
|       |—— todoReducer.js  * reducer
|       |—— main.js         * 将所有reducer进行combin，store.js只引入这个
|
|—— store.js
|
|—— index.js</p> <p>修改代码，引入redux,这里以一个redux todo为demo例子：
index.js</p> <p>import ReactDom from 'react-dom';
import React from 'react';
import Main from './Main/Main.jsx';
import store from './store.js';
import { Provider } from 'react-redux';</p> <p>ReactDom.render(
<Provider store="{store}"><Main></Main></Provider>
, document.getElementById('root'));
store.js</p> <p>import { createStore } from 'redux';
import todoReducer from './reducers/todoReducer.js';</p> <p>const store = createStore(todoReducer);</p> <p>export default store;
tabReducer.js</p> <p>import { ADD_TODO } from '../actions/actionTypes.js';</p> <p>const initialState = {
todoList: []
};</p> <p>const addTodo = (state, action) =&gt; {</p> <p>return { ...state, todoList: state.todoList.concat(action.obj) }
}</p> <p>const todoReducer = (state = initialState, action) =&gt; {
switch(action.type) {
case ADD_TODO: return addTodo(state, action);
default: return state;
}
};
export default todoReducer;
Main.jsx</p> <p>import React from 'react';
import { connect } from 'react-redux';
import { addTodo } from '../actions/todoAction.js';</p> <p>class Main extends React.Component {</p> <pre><code>onClick(){
    let text = this.refs.input;

    this.props.dispatch(addTodo({
        text: text.value
    }))
}
render() {
    return (
        &lt;div&gt;
            &lt;input ref=&quot;input&quot; type=&quot;text&quot;&gt;&lt;/input&gt;
            &lt;button onClick={()=&gt;this.onClick()}&gt;提交&lt;/button&gt;
            &lt;ul&gt;
            {this.props.todoList.map((item, index)=&gt;{
                return &lt;li key={index}&gt;{item.text}&lt;/li&gt;
            })}
            &lt;/ul&gt;
        &lt;/div&gt;
    );
}
</code></pre> <p>}</p> <p>export default connect(
state =&gt; ({
todoList: state.todoList
})
)(Main);
todoAction.js</p> <p>import { ADD_TODO } from './actionTypes.js';</p> <p>export const addTodo = (obj) =&gt; {
return {
type: ADD_TODO,
obj: obj
};
};
使用react-router</p> <p>react-router强大指出在于方便代码管理，结合redux使用更加强大，同时支持web，native更多参考这里</p> <p>安装react-router-dom
npm install react-router-dom --save
如果项目中用了redux，可以安装connected-react-router
npm install connected-react-router history --save</p> <p>修改代码：</p> <p>index.js:
import ReactDom from 'react-dom';
import React from 'react';
import Container from './Main/Container.jsx';
import { store, history } from './store.js';</p> <p>import { Provider } from 'react-redux';</p> <p>import { ConnectedRouter } from 'connected-react-router';</p> <p>ReactDom.render(
<Provider store="{store}"><ConnectedRouter history="{history}"><Container></Container></ConnectedRouter></Provider>
, document.getElementById('root'));
结合history,react-router一共有3中不同的router：</p> <p>BrowserRouter通过history/createBrowserHistory引入:当切换时，url会动态更新，底层使用的时html5的pushState。
HashRouter通过history/createHashHistory引入:当切换时，动态修改hash，利用hashchange事件。
MemoryRouter通过history/createMemoryHistory引入:将路径，路由相关数据存入内存中，不涉及url相关更新，兼容性好。
更多配置可以参考这里</p> <p>如果想要在代码逻辑中获取当前的route的location信息需要在main.js中添加router的reducer:</p> <p>新建main.js:
import { combineReducers } from 'redux';
import { connectRouter } from 'connected-react-router'
import todoReducer from './todoReducer.js';</p> <p>const reducers = (history) =&gt; combineReducers({
todoReducer,
router: connectRouter(history)
});
export default reducers;
编写store.js:</p> <p>import { createStore } from 'redux';
import mainReducer from './reducers/main.js';
import createHistory from 'history/createHashHistory';</p> <p>export const history = createHistory();</p> <p>const store = createStore(
createRootReducer(history),
);</p> <p>export default store;
然后就可以在this.props.router里面获取到相关的location路径信息，其实就是将router对象放在组件的props里面。</p> <p>如果需要自己通过dispatch一个action来触发router的跳转，需要引入routerMiddleware:
import { createStore,applyMiddleware,compose } from 'redux';
import mainReducer from './reducers/main.js';
import createHistory from 'history/createHashHistory';
import { routerMiddleware } from &quot;connected-react-router&quot;;</p> <p>export const history = createHistory();</p> <p>const store = createStore(
createRootReducer(history),
compose(applyMiddleware(routerMiddleware(history)))
);</p> <p>export default store;
最后，将改动同步在index.js长这样：</p> <p>index.js:</p> <p>import ReactDom from 'react-dom';
import React from 'react';
import Container from './Main/Container.jsx';
import store, { history } from './store.js';</p> <p>import { Provider } from 'react-redux';</p> <p>import { ConnectedRouter } from 'connected-react-router';</p> <p>ReactDom.render(
<Provider store="{store}"><ConnectedRouter history="{history}"><Container></Container></ConnectedRouter></Provider>
, document.getElementById('root'));
看到这里，大家可能会对react-router，react-router-dom，connected-react-router，history这些东西给搞晕了，在这里解释一下：</p> <p>react-router：是react-router的核心逻辑，并不涉及到UI，必须引入。
react-router-dom：是react-router的DOM绑定模块，只有用了react-router-dom才能用类似,这些组件，必须引入。
history：是一个让你灵活控制或者模拟浏览器的历史操作的一个库，包括BrowserHistory，HashHistory，MemoryHistory，他可以脱离React使用，也可以结合React使用，可选引入。
connected-react-router：简单来说就是你的项目如果用的React和Redux，如果想要用router的话就可以引入connected-react-router，它能帮你把router的状态放在store里来管理(注意根据你使用的react-router版本不同，会使用不同的版本，它的前身是react-router-redux，官方已经不再维护了)，可选引入。
使用Route和Link和withRouter:</p> <p>先说说都是干嘛的：
Route:component里面的内容即是tab的主要内容，这个从react-router4开始生效：
<Route exact="" path="/" component="{Div1}"></Route> <Route path="/2" component="{Div2}"></Route>
Link:通常也可以用NavLink，相当于tab按钮，控制router的切换,activeClass表示当前tab处于激活态时应用上的class。
withRouter:如果你用了redux，那么你一定要引入它。
export default withRouter(connect(
state =&gt; ({
todoList: state.todoReducer.todoList
})
)(Main));
如果你在使用hash时遇到Warning: Hash history cannot PUSH the same path; a new entry will not be added to the history stack错误，可以将push改为replace即</p> <NavLink replace="{true}" to="/2" activeClassName="selected">切换到2号</NavLink> <p>设置初始化路由：
BrowserRouter和HashRouter:
const history = createHistory();
history.push('2');
MemoryRouter:
const history = createMemoryHistory({
initialEntries: ['/2']
});
使用redux-thunk</p> <p>redux-thunk 是一个比较流行的 redux 异步 action 中间件，比如 action 中有 setTimeout 或者通过 fetch通用远程 API 这些场景，那么久应该使用 redux-thunk 了。redux-thunk 帮助你统一了异步和同步 action 的调用方式，把异步过程放在 action 级别解决，对 component 没有影响。</p> <p>安装redux-thunk:
npm install redux-thunk --save
修改store.js:
import { createStore,applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import mainReducer from './reducers/main';
...
const store = createStore(mainReducer, applyMiddleware(thunk));
...
export default store;</p> <p>在action.js使用redux-thunk：
export const getData = (obj) =&gt; (dispatch, getState) =&gt; {
setTimeout(()=&gt;{
dispatch({
type: GET_DATA,
obj: obj
});
},1000);
};
模块热替换（Hot Module Replacement）</p> <p>模块热替换(Hot Module Replacement 或 HMR)是 webpack 提供的最有用的功能之一。它允许在运行时更新各种模块，而无需进行完全刷新,很高大上有木有！</p> <p>下面说一下配置方法，它需要结合devServer使用：</p> <p>devServer: {
hot: true // 开启HMR
},
开启plugin：</p> <p>const webpack = require('webpack');
plugins: [
new webpack.NamedModulesPlugin(),
new webpack.HotModuleReplacementPlugin(),
].concat(htmlMap)
结合React一起使用：</p> <p>安装react-hot-loader,
npm install react-hot-loader --save
并新建一个Container.jsx:</p> <p>import React from 'react';
import Main from './Main.jsx';
import { hot } from 'react-hot-loader'</p> <p>class Container extends React.Component {</p> <pre><code>render() {
    return &lt;Main /&gt;
}
</code></pre> <p>}
export default hot(module)(Container);
结合redux：如果项目没有使用redux，可以无需配置后面2步</p> <ol start="2"><li>修改store.js新增下面代码，为了让reducer也能实时热替换</li></ol> <p>if (module.hot) {
module.hot.accept('./reducers/todoReducer.js', () =&gt; {
const nextRootReducer = require('./reducers/todoReducer.js').default;
store.replaceReducer(nextRootReducer);
});
}</p> <p>修改index.js
import ReactDom from 'react-dom';
import React from 'react';
import Container from './Main/Container.jsx';
import store from './store.js';</p> <p>import { Provider } from 'react-redux';</p> <p>ReactDom.render(
<Provider store="{store}"><Container></Container></Provider>
, document.getElementById('root'));
当控制台看到[WDS] Hot Module Replacement enabled.代表开启成功</p> <p>使用ESLint</p> <p>ESLint 是众多 Javascript Linter 中的其中一种，其他比较常见的还有 JSLint 跟 JSHint，之所以用 ESLint 是因为他可以自由选择要使用哪些规则，也有很多现成的 plugin 可以使用，另外他对 ES6 还有 JSX 的支持程度跟其他 linter 相比之下也是最高的。</p> <p>安装ESLint
npm install eslint eslint-loader babel-eslint --save
其中eslint-loader是将webpack和eslint结合起来在webpack的配置文件中新增一个eslint-loader种，修改如下</p> <p>{ test: /.(js|jsx)$/, use: [{loader:'babel-loader'},{loader:'eslint-loader'}] ,include: path.resolve(srcRoot)},
新建.eslintrc配置文件,将parser配置成babel-eslint
{
&quot;extends&quot;: [&quot;eslint:recommended&quot;],</p> <pre><code>&quot;parser&quot;: &quot;babel-eslint&quot;,

&quot;globals&quot;: {
},
&quot;rules&quot;: {
}
</code></pre> <p>}
安装eslint-plugin-react:
npm install eslint-plugin-react --save
说明一下，正常情况下每个eslint规则都是需要在rule下面配置，如果什么都不配置，其实本身eslint是不生效的。
eslint本身有很多默认的规则模版，可以通过extends来配置，默认可以使用eslint:recommended。
在使用react开发时可以安装eslint-plugin-react来告知使用react专用的规则来lint
修改.eslintrc配置文件,增加rules，更多rules配置可以参考这里
{
&quot;extends&quot;: [&quot;eslint:recommended&quot;,&quot;plugin:react/recommended&quot;],</p> <pre><code>&quot;parser&quot;: &quot;babel-eslint&quot;,

&quot;globals&quot;: {
    &quot;window&quot;: true,
    &quot;document&quot;: true,
    &quot;module&quot;: true,
    &quot;require&quot;: true
},
&quot;rules&quot;: {
    &quot;react/prop-types&quot; : &quot;off&quot;,
    &quot;no-console&quot; : &quot;off&quot;
}
</code></pre> <p>}
使用axios和async/await</p> <p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端：</p> <p>从浏览器中创建 XMLHttpRequest
从 node.js 发出 http 请求
支持 Promise API
自动转换JSON数据
安装axios:
npm install axios --save
在action中使用axios：
import axios from 'axios';
export const getData = (obj) =&gt; (dispatch, getState) =&gt; {
axios.get('/json/comments.json').then((resp)=&gt;{
dispatch({
type: GET_DATA,
obj: resp
});
});
};
async/await：</p> <p>Javascript的回调地狱，相信很多人都知道，尤其是在node端，近些年比较流行的是Promise的解决方案，但是随着 Node 7 的发布，编程终级解决方案的 async/await应声而出。</p> <p>function resolveAfter2Seconds() {
return new Promise(resolve =&gt; {
setTimeout(() =&gt; {
resolve('resolved');
}, 2000);
});
}</p> <p>async function asyncCall() {
var result = await resolveAfter2Seconds();
}</p> <p>asyncCall();
async/await的用途是简化使用 promises 异步调用的操作，并对一组 Promises执行某些操作。await前提是方法返回的是一个Promise对象，正如Promises类似于结构化回调，async/await类似于组合生成器和 promises。</p> <p>async/await需要安装babel-plugin-transform-async-to-generator。
npm install babel-plugin-transform-async-to-generator --save
在.babelrc中增加配置：
&quot;plugins&quot;: [
&quot;transform-async-to-generator&quot;
]
这样做仅仅是将async转换generator，如果你当前的浏览器不支持generator，你将会收到一个Uncaught ReferenceError: regeneratorRuntime is not defined的错误，你需要：</p> <ol start="3"><li>安装babel-plugin-transform-runtime:</li></ol> <p>npm install babel-plugin-transform-async-to-generator --save
修改.babelrc中的配置(可以去掉之前配置的transform-async-to-generator)：
&quot;plugins&quot;: [
&quot;transform-runtime&quot;
]
如果不想引入所有的polyfill(参考上面对babel的解释),可以增加配置：
&quot;plugins&quot;: [
&quot;transform-runtime&quot;,
{
&quot;polyfill&quot;: false,</p> <pre><code>            &quot;regenerator&quot;: true,
        }
]
</code></pre> <p>结合axios使用：
import axios from 'axios';
export const getData = (obj) =&gt; async (dispatch, getState) =&gt; {
let resp = axios.get('/json/comments.json');
dispatch({
type: GET_DATA,
obj: resp
});
};
Code Splitting</p> <p>对于webpack1，2之前，你可以使用require.ensure来控制一个组件的懒加载：
require.ensure([], _require =&gt; {
let Component = _require('./Component.jsx');
},'lazyname')
在webpack4中，官方已经不再推荐使用require.ensure来使用懒加载功能Dynamic Imports，取而代之的是ES6的import()方法：
import(
/* webpackChunkName: &quot;my-chunk-name&quot; <em>/
/</em> webpackMode: &quot;lazy&quot; */
'module'
);
不小小看注释里的代码，webpack在打包时会动态识别这里的代码来做相关的配置，例如chunk name等等。
3. Prefetching/Preloading modules:</p> <p>webpack 4.6.0+支持了Prefetching/Preloading的写法:</p> <p>//...
import(/* webpackPreload: true */ 'ChartingLibrary');
结合React-Router使用:
react-loadable对上述的功能做了封装，丰富了一些功能，结合React-Router起来使用更加方便。</p> <p>npm install react-loadable --save
在react-router里使用：</p> <p>function Loading() {
return </p><div>Loading...</div>;
}<p></p> <p>let Div2 = Loadable({
loader: () =&gt; import('./Div2'),
loading: Loading,
});</p> <Route path="/2" component="{Div2}"></Route> <p>使用CommonsChunkPlugin</p> <p>CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存起来到缓存中供后续使用。</p> <p>在webpack4之前的用法：
new webpack.optimize.CommonsChunkPlugin({
name: 'common',
chunks: ['page1','page2'],
minChunks: 3
})
name: string: 提出出的名称
chunks: string[]: webpack会从传入的chunk里面提取公共代码,默认从所有entry里提取
minChunks: number|infinity|function(module,count)-&gt;boolean: 如果传入数字或infinity(默认值为3)，就是告诉webpack，只有当模块重复的次数大于等于该数字时，这个模块才会被提取出来。当传入为函数时，所有符合条件的chunk中的模块都会被传入该函数做计算，返回true的模块会被提取到目标chunk。
更多的参数配置，可以参考这里
在webpack4之后的用法：
module.exports = {
//...
optimization: {
splitChunks: {
chunks: 'async',
minSize: 30000,
minChunks: 1,
maxAsyncRequests: 5,
maxInitialRequests: 3,
automaticNameDelimiter: '~',
name: true,
cacheGroups: {
vendors: {
test: /[\/]node_modules[\/]/,
priority: -10
},
default: {
minChunks: 2,
priority: -20,
reuseExistingChunk: true
}
}
}
}
};
splitChunks: 配置一个分离chunk(代替老版本的CommonsChunkPlugin)
cacheGroups: 自定义配置主要使用它来决定生成的文件:
test: 限制范围
name: 生成文件名
priority: 优先级
minSize: number: 最小尺寸必须大于此值，默认30000B
minChunks: 其他entry引用次数大于此值，默认1
maxInitialRequests: entry文件请求的chunks不应该超过此值（请求过多，耗时）
maxAsyncRequests: 异步请求的chunks不应该超过此值
automaticNameDelimiter: 自动命名连接符
chunks: 值为&quot;initial&quot;, “async”（默认） 或 “all”:
initial: 入口chunk，对于异步导入的文件不处理
async: 异步chunk，只对异步导入的文件处理
all: 全部chunk</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/2019/React_V16入门手册.html" class="prev">React_V16入门手册</a></span> <span class="next"><a href="/2019/react生命周期.html">react生命周期</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4498c43d.js" defer></script><script src="/assets/js/2.b4182e24.js" defer></script><script src="/assets/js/17.ead69c87.js" defer></script>
  </body>
</html>
